# 什么是传统的事务管理

我们要**处理**的**一件事情**就是事务

## 一、ACID

是 Atomictiy、Consistency、Isolation、Durability 这四个单词的缩写，分别代表**原子性**、**一致性**、**隔离性**、**持久性**

### 原子性

一件事务不能再被分割，完成就是完成，失败就是失败，**失败后要退回到事务的开始状态**。

### 一致性

当对多个表进行操作的时候，要保持他们的**行为一致**(就是经常举例的订单、库存、余额的行为保持一致)

### 隔离性

当同时处理多个事务，**事物之间要保持隔离**，互不影响。

### 持久性

一个事务完成，**事务的最终形式应该被永久的保存下来**，无论是数据库，还是日志表或者其他..



## 二、传统事务的实现

事务实现有两种方式，一种 WAL，一种影子分页

### 1. WAL(Write Aheading Logging)

核心思想就是在数据库中，在进行真正的数据改变时，**首先应该先记录日志，而不是直接增删改查。**

这样在数据库崩溃时，也可以依赖日志来对数据进行恢复，所以说我们拥有日志，就相当于就有数据库的 ACID

**而尚未记录到数据页里的数据，都会先从日志记录中进行重做(也叫向前滚动恢复，也叫 REDO)**

**然后那些尚未提交的事务的修改，将会从日志记录中删除(也叫向后滚动恢复，也叫 UNDO)**

现代数据库中大多使用这种方式

### 2. 影子分页(Shadow paging)

每个 page 只在日志文件中保存一份，无论被修改多少次。日志文件中，只记录事务开始前 page 的原始信息，恢复时只要利用日志文件将 page 进行覆盖

```
A    |->|                  // 日志A记录原始的记录
B    |-------->---->  |    // 数据页进行事务时，修改了两次，但最后失败
B    |->|                  // 事务失败回滚到日志记录的初始位置
```

```
A    |->|                  // 日志A记录原始的记录
B    |-------->---->->|    // 数据页进行事务时，修改了三次，事务成功
B    |                |->  // 事务执行结束阶段数据
A    |                |->  // 日志保存最新的记录，之前的事务内容会被截断，删除
```



在实际中，我们大多使用的是 AutoCommit，并没有很直观的看到事务的过程，实际上这些工作都由数据库来实现了



## 三、Spring 中的事务管理

Spring 是我经常使用的框架，待续..



上述是传统的事务管理，那么分布式的事务管理是如何的，需要懂些基本的 [CAP 和 BASE 理论](./CAP 和 BASE 理论.md)

