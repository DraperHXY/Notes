# 一、Elastic Stack
包括有以下几个
* Elasticsearch 存储，搜索
* Kibana 展示
* Beats 采集
* Logstash 传输


Lucene 提供全文检索的接口，但不能单独使用

而Elasticsearch 以及 Solr 就是基于 Lucene 实现的

# 二、Elasticsarch 的数据格式
先有个类比，大致参考
Elasticsearch - MySQL
Index(索引) - Database(数据库)
Type(类型) - Table(表)
Documents(文档) - Row(行)
Fields(字段) - Column(列)

## 1. index
一个索引就是拥有几分相似特征文档的集合

## 2. type
type 就是索引下面的一个分类，但是在 es 中，万物都和索引关联在一起，平时也主要使用索引，所以在索引和数据之间不应该有个额外的间隔，所以在后续版本的 es 中取消了 type 这一类型

## 3. documents
一个 documents 就是 json

## 4. fields
一个 fields 就是一个字段

## 5. mapping
mapping 简单来看就是规定 documents 的格式，比如说数据类型，默认值，分析器，是否被索引

## 6. shards
es 提供将一个索引分成几份索引，从而实现扩容，存下包括超过一个节点的硬件限制，存储大量数据，而每份索引就被称为分片

分片的概念很重要，有以下两点原因
* 允许水平分割，扩容
* 允许在分片上进行分布式、并行的操作，从而提高性能和吞吐量

## 7. replicas
es 允许创建分片的一份或者多份拷贝，以防一个分片宕机，这个拷贝就叫副本

## 8. allocation
分配，将分片分给节点的过程，包括主节点，或者副本。如果是副本还包括主从副本复制数据的过程，这都交给master节点处理，这叫分配

一个节点可能既有分片又有索引


# 三、倒排索引

## 正排索引

id    content
-------------
1001  my name is zhang san

1002  my name is li si

在模糊查询的时候，性能会差很多，比如大写 Zhang san


## 倒排索引
keyword     id
--------------
name      1001,1002
zhang     1001


# 四、分词器
如果一个索引该怎么分词，这取决于分词器，在一些字段如果是 ``text`` 代表可以被分词，如果是 ``keyword`` 代表不能被分词

还有一些其他设置
ik_max_word 最细粒度的拆分
ik_smart 最粗粒度的拆分

词条 索引最小存储和查询单元，例如 ``zhangsan`` 可以查 ``san``
词典 字典、词条的组合，用B+树和HashMap

倒排表 
先看词典，看倒排列表中的指针，通过指针获取文档 id，再通过文档 id 进行查询

# 五、文档搜索
早期会为文档建立一个强大的倒排索引，然后将倒排索引写入到磁盘，一旦新的索引就绪，旧的就会被替换，这样变化就可以被检索到。被写入到磁盘是不会改变的，这个不变性指的是不会被修改，但是可以被删除

所以这个不变性会有以下几点好处
1. 不需要锁。如果从来不更新索引，那么就不会担心多进程同事修改数据的问题
2. 一旦索引被写入到文件系统的缓存，就会留在缓存，由于其不变性，只要文件系统缓存中还有足够的空间，那么大部分请求会直接请求内存，而不会命中磁盘
3. 倒排索引可以被压缩，减少磁盘I/O和需要缓存到内幕才能的索引的使用量

但是有不好的地方就是创建好就不能被修改，如果频繁修改，就会导致性能变差

所以可以有补充索引，来补充修改。另外删除文档的时候并不是真正删除，而在 .del 文件中标记删除，

# 六、近实时搜索
首先有个按段搜索 per-segment，es 中的每一段都是一个倒排索引，最新的数据更新会体现在段上，

## 基本I/O
### 1. 写入操作
写入的时候不仅要写入分片，为了安全性还会写入副本，会增加写入延时

先写 index，但实际上每个 index 就代表一个数据对象，端。这个段在内存中，还要将端写入磁盘

为了以防内存中的数据丢失，在内存中会有一个类似于日志文件的 tanslog，磁盘中也会有 translog

同时在 memory 和 disk 中间，会有一层 os cach 来

### 2. 查询


分词器针对特殊keyword可以手动添加，例如弗雷尔卓德