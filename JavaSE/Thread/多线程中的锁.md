# 多线程中的锁

简单说就是在同一时刻，只能有一个线程能够访问受限资源的限制叫做锁。

加锁的目的是为了更好地使用资源(保证线程安全)

锁的范围，可以是对象，代码段，整个方法



## 死锁

就是两个线程都在等待对方释放资源，互不相让就是死锁。做一个比喻，两个厨师，一个拿着醋等着别人的酱油，另外一个拿着酱油等着别人放下醋

实现一个简单简单的死锁不需要很复杂，[使用两个 Object 实现死锁](https://github.com/DraperHXY/JavaLearning/blob/master/src/main/java/com/draper/thread/DeadLock.java)



## synchronized

``synchronized`` - ``/ˈsiNGkrəˌnīz/`` 

一个依赖于操作系统实现的重量级锁，通过对象内部的一个 ``monitor`` 来实现。本质又依赖于底层的操作系统 ``Mutex Lock`` 来实现的。而操作系统实现线程之间的切换需要从``用户态``转换到``核心态``，成本相当高，这也是 synchronized 效率低下的原因。

> 既然说到了用户态和内核态，简单介绍一下
>
> 用户态：进程执行用户自己的代码，称其为用户态
>
> 内核态：当进程执行系统调用而陷入内核代码中执行时，称其为内核态
>
> 区别：区别很多，围绕着资源消耗解释下就是内核态需要操作系统内核的支持，调度创建等，用户态就是仅在语言层面就可以完成创建、调度，撤销



使用 synchronized 实现一个简单的 demo

```java
public void method(){
    synchronized (this){
        System.out.println("代码块");
    }
}
```

查看字节码文件，这个是由 IDEA 插件 ``jclasslib`` 导出的

```java
 0 aload_0
 1 dup
 2 astore_1
 3 monitorenter
 4 getstatic #2 <java/lang/System.out>
 7 ldc #3 <代码块>
 9 invokevirtual #4 <java/io/PrintStream.println>
12 aload_1
13 monitorexit
14 goto 22 (+8)
17 astore_2
18 aload_1
19 monitorexit
20 aload_2
21 athrow
22 return
```

在第 3行 和 13 行分别是加锁和释放锁。synchronized 是通过对象在内存中的存储结构的头部的 monitor 实现的，如果计数器为 0 则，获得锁，如果为 1，则阻塞。





在 JDK 1.6 以后，为了减少获得锁，释放锁所带来的性能消耗，提高性能，引入了大量的优化。如自旋锁，适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来较少锁操作的开销。这些名字都很有误导性，其实都是对获取锁方式的优化，并不是锁。

**而 Sychronized 并不是绝对的重量级，针对在 JDK 优化后，需要测试才能得出最终的结论**



## 偏向锁

偏向锁的目的和引入轻量级的锁很像，都是为了多线程竞争情况下，减少重量级的锁使用操作系统互斥而产生的性能消耗。但是不同的是：轻量级锁在无竞争情况下会使用 CAS 将整个同步操作都消除掉。

偏向锁的特征就是第一个获取锁的线程，如果在接下来的执行中，该锁没有被其他锁获取，那么久不需要申请互斥，可以直接使用。JVM 在使用 锁 的时候会优先使用偏向锁，在多次偏向锁竞争失败后将会锁升级



## 轻量级锁

若偏向锁失败，虚拟机不会立即升级为重量级锁，而是使用一种轻量级锁，来代替重量级锁。在没有竞争的情况下，可以很容易的提高资源获取效率，但是在由竞争的情况下，轻量级锁会比传动的重量级锁更慢。



## 自旋锁

在轻量级锁失败后，虚拟机为了避免线程真实地在操作系统曾面挂起，还会进行一项自旋优化。

互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态去完成。

而一般情况下，一个线程持有锁的时间都不是太长，所以仅仅为了一点点时间去**挂起线程/恢复线程是得不偿失的**。所以需要等待一定的时间，所以需要让线程等待一会儿，且不能被挂起，所以**为了让线程等待，我们需要让线程执行一个忙循环。这个技术就叫做自旋**



自旋锁在 JDK 1.6 就已经引入了，不过默认是关闭的，需要通过 ``—XX:userSpinning`` 参数来开启。JDK 1.6 和之后的，就改为默认开启的。需要注意的是自旋锁不能完全替代阻塞，因为他还是占用处理器时间。如果锁被占用的时间短，那么自旋锁的效率就很高，反之，自旋等待的时间必须要有限度，。如果超过了限定次数的锁还没有获得锁，就因该挂起线程。自旋次数的默认值是 10 次，用户可以进行修改  ``—XX:PreBlockSpring``来更改。



#### 适应性自旋锁

在 JDK 1.6 中引进了自适应的自旋锁。带来的优势就是，自旋的时间不固定了，而是和前一次同一个锁上自旋时间以及锁的拥有者的状态决定，虚拟机变得越来越聪明了。



## 锁消除

虚拟机在编译的时候，如果发现一些共享数据并不可能存在竞争，那么就执行锁消除。以节省无意义的请求锁的时间。



### 锁粗化

原则上就，我们编写代码，总是推荐同步快，是的加锁的范围尽量小，一直在共享数据的实际作用域才进行同步。大部分情况下，上面的原则是没有问题的，如果在进行锁竞争，那等待线程也可以尽快的拿到锁。



## Synchronized 和 ReenTrantLock 对比

* 两者都是可重入锁

意思就是自己可以获取自己的内部锁。比如一个线程获得了某个资源，并给这个资源加锁。此时这个对象的锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都会增一，所以要等到他们的计数器下降为 0 的时候才会释放锁。

* synchronized 依赖于 jvm， ReenTrantLock 依赖于 API (AQS)

sychronized 依赖于 JVM，虚拟机团队在 JDK 1.6 为 synchronized  做了许多的优化，但都是在虚拟机方面实现，并没有暴露给我们。ReenTrantLock 是 JDK 层面实现的，需要 lock() 和 unlock() 方法配合 try/finally 语句来完成，可以直接查看源代码是怎么实现的。

* ReenTrantLock 还有一些高级功能，实现公平锁等





