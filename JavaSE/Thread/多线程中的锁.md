# 多线程中的锁

简单说就是在同一时刻，只能有一个线程能够访问受限资源的限制叫做锁。

加锁的目的是为了更好地使用资源(保证线程安全)

锁的范围，可以是对象，代码段，整个方法



## 死锁

就是两个线程都在等待对方释放资源，互不相让就是死锁。做一个比喻，两个厨师，一个拿着醋等着别人的酱油，另外一个拿着酱油等着别人放下醋

实现一个简单简单的死锁不需要很复杂，[使用两个 Object 实现死锁](https://github.com/DraperHXY/JavaLearning/blob/master/src/main/java/com/draper/thread/DeadLock.java)



## synchronized

``synchronized`` - ``/ˈsiNGkrəˌnīz/`` 

一个依赖于操作系统实现的重量级锁，通过对象内部的一个 ``monitor`` 来实现。本质又依赖于底层的操作系统 ``Mutex Lock`` 来实现的。而操作系统实现线程之间的切换需要从``用户态``转换到``核心态``，成本相当高，这也是 synchronized 效率低下的原因。



在 JDK 1.6 以后，为了减少获得锁，释放锁所带来的性能消耗，提高性能，引入了大量的优化。如自旋锁，适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来较少锁操作的开销。这些名字都很有误导性，其实都是对获取锁的优化，并不是锁。





下一回学习 CAS ABA 和这些锁的概念



