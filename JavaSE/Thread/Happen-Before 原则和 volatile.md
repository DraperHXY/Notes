# Happen-Before 原则和 volatile



## 一、程序的执行顺序与重排序

先看一个小例子

```java
public class A implements Runnable {
    public Integer a = 0;
    public Integer b = 0;
    public Integer c = 0;
    public Integer d = 0;
    public Integer e = 0;
    @Override
    public void run() {
        a = 1;
        b = 2;
        c = a + b;
        d = 4;
        e = 5;
    }
}
```

看上面的程序，其中包含有五个赋值语句，直觉中程序的执行顺序是依次从上到下进行，这也是 Happen-Before 望文生义的理解，但是编译器会针对程序进行特定的优化，从而将指令进行重新排序，更好的提高执行效率。

简单想，如果为了提高程序执行的效率，也不能让程序的执行顺序发生错乱，所以可以想一下上面的赋值语句怎样排序才不会造成执行问题。

比如说

```java
b = 2;
a = 1;
c = a + b;
d = 4;
e = 5;
```

或者

```java
a = 1;
b = 2;
c = a + b;
e = 5;
d = 4;
```

这是一个非常朴素的概念，也是符合人的阅读习惯的概念，**一个后者依赖前者，不能因为前者的顺序，赋值会有不同的结果**

---

## 二、再看 volatile

### 1. 禁止指令重排序

如果赋值语句只有两句

```java
a = 1;
b = 2;
```

如何确保第一句永远在第二句执行之前，可以给变量加一个关键字，volatile

即 ``public volatile Integer b = 0;``

这就是 **voliatile 的 Happen-Before 的规则——禁止指令重排序**

### 2. 可见性

都知道 CPU 运行速度最快，内存其次。CPU 在高速运转的时候，为了图存取方便，会临时将变量副本存在 CPU 的缓存中。但是对于其他的线程来说，变量的引用是存在线程的内存空间里，实质存在主内存里。从而在多线程的情况下对变量进行操作的时候，理想情况下，其他线程也会感知到变量的改变。但是多核 CPU 缓存的特性，会造成多线程情况下，线程取到的值有差异（来自分布在多核 CPU 的不同缓存或者主内存）

**所以 volatile 是强制将 CPU 运算后的变量刷入主存（换个角度讲，不利用缓存降低了效率）**，所以这就是 volatile 的可见性。

但是这并不能说明这就是线程安全的，因为仅仅保证多个线程读到的是一样的值，不确定后面哪些线程又多次进行了赋值，举个例子 a++ 多线程操作的例子；

```java
a = 0;  // 这是大家从主存里面读到的值
a++;    // a = 1  // 模拟多线程 for 循环，方便阅读每次循环我拆开了
a++;    // a = 2  // A 线程将值赋值为 2
a++;    // a = 2  // B 线程将值赋值为 3
a++;    // a = 3  // A 想成将值赋值为 3
```

理论上这个时候 a 的值经过四次循环应该是 4，但多线程写，从而造成数据的丢失，这就是线程不安全的体现，所以就有了占用（加锁）一说

声明对变量的占有权，一个线程在操作变量的时候，其他线程必须等待。

剩下的就是锁的内容了，超出本文的范围了。















