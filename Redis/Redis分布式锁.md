# Redis分布式锁

## 一、基本使用

**锁就是占坑**，无论 Java 还是 Redis 都是如此，有人占用，就不能操作，没人占用，才可以进行操作

在 Redis 中是通过 ``setnx`` 来实现分布式锁

setnx(set if not exist) 后等待使用 ``del`` 指令释放锁。

```
127.0.0.1:6379> setnx lock:codehole true
(integer) 1
// do something
127.0.0.1:6379> del lock:codehole
(integer) 1
```



但是上述代码任然有问题，假设程序出了异常，迟迟没有释放锁，容易导致整个系统陷入死锁

所以可以给锁一个过期时间

```
127.0.0.1:6379> set lock:codehole true ex 5 nx
OK
// do something
127.0.0.1:6379> del lock:codehole
(integer) 1
```

上述这段代码就是分布式锁的奥义所在



## 二、使用要点

### 锁超时，被其他线程占用

当一个线程占用锁超时，导致锁被释放，另外一个线程获取锁进行操作。此时容易导致异常，所以**长时间的任务，不要使用 Redis 分布式锁**



### 锁占用，被其他线程释放

可以在 set value 时设置一个随机值，在 del 时会进行一个随机数匹配，如果匹配成功则释放锁，这是为了避免误操作，除非这个锁过期了

**但是匹配一个 value 然后删除一个 key 并不是原子操作，可以通过 Lua 脚本来保证多个操作的原子性**（PS: Lua 脚本可以通过 Lua 来执行）





### 可重入性

可重入性是指线程在持有锁的情况下再次请求加锁，若果一个锁支持同一个线程多次加锁，那么说明是支持可重入的。

在 Java 中 ReentrantLock 就是可重入锁。

在 Redis 中其实不推荐使用可重入锁，这会大大增加客户端的复杂性

可以通过客户端 ThreadLocal 和引用计数实现可重入



## 三、缺点

1. 获取锁是非阻塞
2. 非公平锁，不支持需要公平锁的场景
3. redis 主从存在延迟，在 master 发生主从切换，可能导致锁失效