# Redis 缓存更新策略

先来通常读取的时候的策略

1. 先查询缓存，若命中缓存则直接返回
2. 没命中缓存，查询数据库，更新缓存

读取的并发显然没有问题，若是两个线程同样开始读，都读到缓存没有数据，都会查询数据库，同时更新缓存，这个时候并发逻辑是正确的。但是在写的时候操作要格外小心。



通常在设计缓存架构的时候需要有针对性的讨论，毕竟**高可用**和**高性能**以及**一致性**彼此之间都是有些**鱼和熊掌不可兼得的意味**。所以要考虑业务场景：

1. 是要求最终一致性，还是强一致性
2. 对缓存的一致性的要求有多高？延迟 1ms 行不行？延迟 1min ?
3. 单库单表？多库多表？
4. 缓存的数据结构是怎样的？
5. 该如何容灾？对更新、删除失败能否接收？写数据库失败怎么办？
6. 如果删除缓存失败，还允不允许更新数据库？
7. ...





## 一、缓存更新策略的基本方式

1. Cache aside
2. Read through
3. Write through
4. Write behind caching

这应该是属于缓存的设计模式，不论是在 Redis 中，还是在 Memcache 或者是操作系统的底层，都有他们的身影

先不考虑各种操作失败的情况

### 1. Cache aside

先更新数据库

然后删除缓存



### 2. Read through

是在指查询操作，如果没有命中缓存，则由一个统一的访问介质层来更新缓存，而在 Cache aside 中，则是由调用方更新缓存的，而在 Read Through 中更新缓存对于调用方来说是透明的。



### 3. Write through

是在指更新操作的时候，命中谁，更新谁。比如没有命中缓存，那就直接更新数据库。命中了缓存，那就直接更新缓存，然后由 Cache 自己维护数据库



### 4. Write Behind Caching Pattern

这个也是 Linux 文件系统的 Page Cache 算法。简单说就是操作的时候先操作内存，然后异步更新数据库。这样的话 IO 操作快的飞起，还可以进行批量操作。但是这个算法并不是强一致性，存在丢失数据的危险。（Unix/Linux 非正常关机，可能会导致数据丢失就是这个原因） 




