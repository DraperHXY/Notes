### JVM

1、地球人都知道，Java有个东西叫垃圾收集器，它让创建的对象不需要像c/cpp那样delete、free掉，你能不能谈谈，GC是在什么时候，对什么东西，做了什么事情？

> 系统不可预测时间，调用 System.gc()
>
> 能说出新生代、老年代结构，能提出 minor gc/full gc
>
> 以及相应的触发条件、OOM 的触发条件，降低 GC 的调优策略
>
> 例如 eden 满了 minor gc，升到老年代的对象大于老年代剩余空间 full gc
>
> 或者小于时被 HandlePromotionFailure 参数强制 full gc
>
> gc 和 full gc 时间耗时超过了 GCTimeRatio 的限制引发 OOM
>
> 调优诸如通过 NewRatio 控制新生代老年代比例
>
> 通过 MaxTenuringThreshold 控制进入老年前生存次数等...
>
> 
>
> 对从 root 搜索不到，而且经过第一次标记，清理后，任然没有复活的对象
>
> 
>
> 新生代做的是复制清理、from survivor、to survivor 是干什么用的、老年代做的是标记清理，清理后碎片要不要整理、赋值清理和标记清理有什么优劣势
>
> 串行、并行(整理/不整理碎片)、CMS 等搜集器可作用的年代、特点、优劣势，并且能说明控制、调整收集器选择法
>
> 法
>
> - 新生代的垃圾回收
>
> 新对象的内存分配都是现在 Eden 区域，当 Eden  区域的空间不足于分配新对象时，就会触发年轻代上的垃圾回收（发生在 Eden 和 Survivor 内存区域上），我们称之为 "minor garbage collection"，同时，每个对象都有一个 "年龄"，这个年龄实际上是该对象经历过的 minor gc 的次数，所有存货的对象（任然可达对象）会被拷贝到其中一个 Survivor 区域，同时年龄增长为 1。并清除整个 Eden 内存区域中的非可达对象。
>
> 当第二次 minor gc 被触发时，JVM 会通过 Mark 算法找出所有在 Eden 内存区域和 Survivor1 内存区域存活的对象，并将它们拷贝到 Survivor2 区域（这也就是为什么需要两个大小一样的 Survivor 区域的原因），同时对象的年龄加 1，最后，清除所有在 Eden 内存区域和 Survivor1 的非可达对象。
>
> 当对象的年龄足够大（这个年龄可以通过 JVM 参数进行制定，这里假定是 2），当 minor gc 再次发生时，他会从 Survivor 内存你区域中升级到年老代
>
> 其实，即使对象的年龄不够大，但是 Survivor 内存区域中没有足够的空间来容纳 Eden 升级过来的对象时，也会有部分对象直接升级到 Tenured 内存区域汇中。
>
> - 年老代的垃圾回收
>
> 当 minor gc 发生时，又有对象从 Survivor 区域升级到 Tenured 区域已经没有空间容纳新的对象了，那么这个时候就会触发老年代上的垃圾回收，我们称之为 "major garbage collection"
>
> 而年老代上的选择的垃圾回收算法取决于 JVM 上采用的是什么垃圾回收器。垃圾回收器有两种 Parallel Scavenge(PS) 和 Concurrent Mark Sweep(CMS)。这两种垃圾回收器的不同更多的是体现在年老代的垃圾回收过程中，年轻代的垃圾回收在这两种垃圾回收器基本一致
>
> 就像其名字所表示的那样，Parallel Scavenge 垃圾回收器在执行垃圾回收时使用了多线程来记性垃圾回收，这样可以提高垃圾回收的效率。而 Concurrent Mark Sweep 垃圾回收器在进行垃圾回收时，应用程序可以同时进行。
>
> 原文 [Java 垃圾回收机制](https://www.jianshu.com/p/778dd3848196)





2、Java 和 C++ 在内存分配和管理上有什么区别？

> 对于从事 C 和 C++ 程序开发人员来说，在内存管理领域，既拥有每一个对象的所有权，又担负着每一个对象从生命开始到终结的维护责任
>
> 对于 Java 程序员来说，虚拟机的自动分配机制的帮助下，不再需要为每一个 new 操作去写配对的 delete/free 代码，而且不容易出现内存泄漏和内存溢出问题，看起来虚拟机管理内存一切都很美好。不过，也正是因为 Java 程序员将内存控制的权利交给 Java 虚拟机，一旦出现内存泄漏和内存溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查是一项异常艰难的工作
>
> 的
>
> 好的 Java 程序在编写时候肯定要考虑 GC 的问题，怎样定义 static 对象，怎样 new 对象效率高等等，简称面向 GC 的编程



3、Java 虚拟机规范将 JVM 虚拟机所管理的内存分为个部分

> - 程序计数器(Program Counter Register)
>
> 是一块比较小的内存空间，它的作用可以看做是当前线程所执行字节码的行号指示器。是线程私有，生命周期与线程相同
>
> - Java 虚拟机栈(Java Virtual Machine Stacks)
>
> 也是线程私有，生命周期与线程相同。Java 虚拟机栈描述的是 Java 方法(区别于 native 本地方法) 执行的内存模型：每个方法被执行的时候都会出现一个栈帧(Stack Frame) 用于存储局部变量表、操作栈、动作链接、方法出口等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
>
> - 本地方法栈(Native Method Stacks/VM Stack)
>
> 与虚拟机栈所发挥的作用非常相似，其区别不过是虚拟机栈为执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机所使用到的 Native 方法服务。
>
> - 方法区(Method Area)
> - 堆(Heap)



4、有哪些方法可以判断一个对象已经可以被回收，JVM怎么判断一个对象已经消亡可以被回收？

> - 引用计数法
>
> 给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加 1；当引用失效时，计数器值就减 1；任何时刻计数器都为 0 的对象就是不可能再被使用的。
>
> Java 语言没有选用引用计数法来管理内存，因为引用计数法不能很好的解决循环引用的问题
>
> ```java
> class A {
>    public Object o;
> }
> class B {
>    public Object o;
> }
> void method(){
>    A a = new A();
>    B b = new B();
>    a.o = b;
>    b.o = a;
>    a = null;
>    b = null;
> }
> public static void main(String[] args) {
>    new Test1().method();
> }
> ```
>
> - 根搜索算法
>
> 在主流的商用语言中，都是使用根搜索算法来判定对象是否存货的。
>
> GC Root Tracing 算法思路是通过一些列名为 ”GC Roots“ 的对象作为起始点，从这些节点向下搜索，搜索走过的路径被称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连，即从 GC Roots 到这个对象不可达，则证明此对象是不可用的。



5、哪些对象可以作为 GC Roots？

> - 虚拟机栈(栈帧中的本地变量表)中的引用的对象(作 GCRoots 又不会损失什么)
> - 方法去中类静态属性引用的对象
> - main thread 
>
> 一个 thread，本身就是一个大的实例，
>
> - 本地方法栈中（Native）的引用对象(JNI 引用)



6、在 Heap 中没有类的实例的时候，类信息还存在于 JVM 中吗？存在于什么地方？

> JVM 将堆分成了两大分区 Young 和 Old



7、JVM 垃圾回收算法

> - 因为引用计数法无法解决循环引用问题，JVM 并没有采用这种算法来判断对象是否存货
> - JVM 一般采用 GCRoots 发放，只要从任何一个 GCRoots 的对象科大，就是不被回收的对象



8、判断了对象的生死，怎么进行内存的清理呢？

> - 标记-清除算法
>
> 先标记那些要被回收的对象，然后进行清理，简单可行，但是标记清除效率低，因为要一个一个标记和清除，造成大量不连续的内存碎片，空间碎片太多可能会导致当程序在以后的运行过程中需要分配较大对象的时候无法找到足够连续的内存而不得不触发另一次垃圾回收动作
>
> - 复制收集算法
>
> 将可用内存按照容量分为大小相等的两块，每次只是使用其中一块。当这一块的内存用完了，就将可用内存汇总存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配也就不用考虑内存碎片等复杂情况，只要一动堆顶指针，按顺序分配内存即可。实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一般，未免太高了一点。
>
> > young 内存分为三块，Eden,Survivor1,Survivor2 以及 FROM TO 相对使用的用法。
> >
> > 前两者属于年轻代的垃圾回收，后者属于年老代的垃圾回收
> >
> > - 标记压缩算法
> > - 分代算法
> > - 分区算法



9、年老代的垃圾回收机制

> - Parallel Scavenge
>
> PS垃圾回收器在年老代上采用的垃圾回收算法可以看作是[标记-清除算法](https://www.jianshu.com/p/b0f5d21fe031)和[标记-压缩算法](https://www.jianshu.com/p/698eb5e1ccb9)的结合体。
>
> 首先，PS 垃圾回收器先是会在年老代上使用标记-清除算法来回收掉飞科达对象所占用的空间，但是我们知道，标记清除算法的一个缺陷就是会引起内存碎片问题。继而有可能会引发连续的 major gc。假设当前存在的内存碎片有 10M，但最大的内存碎片只能容纳 2M 的对象，这个时候如果有一个 3M 的对象从 Survivor 区域升级到 Tenured 区域，那 Tenured 区域也没有方法存放这个 3M 的对象。结果就是不断地触发 major gc,直到 Out of Memory。所以，PS 垃圾回收器在清除非可达对象后，还会进行一次 compact，来消除内存碎片。
>
> - Concurrent Mark Sweep
>
> CMS 垃圾收集器相比于 PS 垃圾收集器，它成功的减少了垃圾收集时暂停应用程序的时间，因为 CMS 在进行垃圾收集时，应用程序是可以并发运行的。
>
> 
>
> 从名字可以看出，CMS 垃圾收集器在年老代采用的垃圾回收算法是标记-清除算法。但是跟标准的标记-清除算法略有不同。主要分为四个阶段。
>
> - Initial Mark 阶段
>
> 这个阶段是 Stop-The-World，他会暂停应用程序的运行，但是在这个阶段，他不会标记出在 Tenured 区域中所有的可达对象。他只会从根对象开始出发，标记到根对象的第一层孩子节点即停止。然后恢复应用程序的运行。所以，这个暂停应用程序的时间是很短的
>
> - Concurrent Mark 阶段
>
> 在这个阶段中，CMS 垃圾回收器以 Initial Mark 阶段标记的节点为根对象，重新考试标记 Tenured 区域中的可达对象。当然，在这个阶段中是不需要暂停应用程序的。这也是它成为 "Concurrent Mark" 的原因。这同时也造成了一个问题，俺就是由于 CMS 垃圾回收器和应用程序同时运行，Concurrent Mark 阶段它并不保证 Tenured 区域的可达对象都被标记了，应用程序一直在分配新对象。
>
> - Remark 阶段
>
> 由于 Concurrent Mark 阶段它并不保证在 Tenured 区域的可达对象都被标记，所以我们需要再次暂停应用程序，确保所有的可达对象都被标记。为了加快速度，这里也采用了多线程同时标记可达对象。
>
> - Concurrent Sweep 阶段
>
> 最后，恢复应用程序的执行，同时 CMS 执行 sweep，来清除所有非可达对象所占用的内存空间。
>
> 所以，相比于 PS 垃圾收集器，CMS 垃圾收集器成功减少了应用程序暂停的时间。
>
> - 除此之外 Java7 的发布了新的 Garbage First G1 垃圾回收器
>
> 原文 [Java 垃圾回收机制](https://www.jianshu.com/p/778dd3848196)



10、Java7 的 Garbage First 垃圾回收器

> Garbage First(G1) 垃圾收集器
>
> 但是很不幸的是，CMS 垃圾收集器虽然减少了暂停应用程序的运行时间，但是由于它没有 Compact 阶段，他还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时保留 CMS 垃圾收集器低暂停时间的优点，Java 7 发布了一个新的垃圾收集器 - G1 垃圾收集器。它会在未来逐步替换掉 CMS 垃圾收集器。
>
> 
>
> G1 垃圾收集器和 CMS 垃圾收集器有几点不同。首先，岁大的不同是内存的组织方式改变了。Eden, Survivor 和 Tenured 等内存区域不再是连续的了，而是变成了一个个大小一样的 region，每个 region 从 1M 到 32M 不等。
>
> 
>
> 一个 Region 有可能属于 Eden, Survivor 或者 Tenured 内存区域。G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，主要用于存储大对象，即大小超过了一个 region 大小的 50% 的对象。
>
> 
>
> 在 G1 垃圾收集器中，年轻代的垃圾回收过程和 PS 垃圾收集器和 CMS 垃圾收集器差不多，新对象的分配还是在 Eden region 中，当所有 Eden region 的大小超过某个值时，触发 minor gc，回收 Eden region 和 Survivor region 上的非可达对象，同时升级存活的咔哒对象到对应的 Survivor region 和 Tenured region 还是哪个。对象从 Survivor region 升级到 Tenured region 依然是取决于对象的年龄。
>
> 
>
> 对于年老代的垃圾收集，G1 垃圾收集器也分为 4 个阶段，基本跟 CMS 垃圾收集器一样，但略有不同
>
> 
>
> - Initial Mark 阶段
>
> 同 CMS 垃圾收集器的 Initial Mark 极端一样，G1 也需要暂停应用程序的执行，它会标记从根对象触发，在根对象的第一层孩子节点中标记所有可达的对象。但是 G1 的垃圾收集器的 Initial Mark 阶段是跟 minor gc 一同发生的。也就是说在 G1 中，不用像 CMS 那样，单独暂停应用程序的执行来运行 Initial Mark 阶段，而是在 G1 触发 minor gc 的时候一并将年老代上 Initial Mark 给做了。
>
> - Concurrent Mark 阶段
>
> 在这个阶段 G1 做的事情跟 CMS 一样。但 G1 同时还多做了一件事情，那就是，如果在 Concurrent Mark 阶段中，发现那些 Tenured region 汇总对象的存活率很小或者基本没有对象存活，那么 G1 就会在这个阶段将其回收掉，而不用等到后面的 clean up 阶段。这也是 Garbage First 名字的由来。同时在这个阶段，G1 会计算每个 region 的对象存活率，方便后面的 clean up 阶段使用
>
> - Remark 阶段
>
> 在这个阶段 G1 做的事情更 CMS 一样，但是采用的算法不同， G1 采用的叫做 SATB(snapshot-at-the-begining) 的算法能够在 Remark 阶段更快的标记可达对象。
>
> - Clean up/Copy 阶段
>
> 在 G1 中，没有 CMS 中对应的 Sweep 阶段。相反他有一个 Clean up/Copy 阶段，在这个阶段中，G1 会挑选出那些对象存活率低的 region 进行回收，这个阶段也是和 minor gc 一同发生的。



