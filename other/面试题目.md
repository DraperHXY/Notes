已学习

* Java 基础(OOP)
* Spring 
* MyBatis



待学习

* 锁

  [Java 各种锁的小结](https://juejin.im/post/5c5cf03ef265da2dd218a4c8?utm_source=gold_browser_extension)

* 线程





# 我的面试题目汇总

## Java 问题汇总

### 集合

1、List，Set，Map三者的区别及总结

> * List 按照插入顺序存储
> * Set 不允许重复元素的集合
> * Map 通过 ``key`` 来存储其 ``value``



2、ArrayList 和  LinkedList 区别

> * ArrayList
>
>   **底层使用了数组**，存读效率比较高，插入删除特定的位置效率比较低
>
> * LinkedList
>
>   **底层使用了双向循环链表**，插入删除效率比较高



3、HashMap 和 Hashtable 的区别

> * HashMap
>
>   * 时间复杂度为 O(1)
>   * 继承了 ``AbstractMap ``
>   * 非线程安全
>   * 既允许 key 为 null 也允许 value 为 null
>   * 扩充机制大量使用了位运算，方便散列后的数据相对于散列前的没有大量移动
>   * 如果数据分布出现极端不均匀 jdk 1.8 会比 jdk 1.7 快，当每个节点超过 8 个值，则会从链表转为红黑树
>   * Hash 计算使用 JDK 提供的 hashcode，并将 hashcode 使用位运算打散
>
> * Hashtable
>
>   * 继承了 ``Dictionary``，Dictionary 已经被废弃
>
>   * 线程安全
>
>   底层方法大量使用了 synchronized 进行同步，所以效率比很低
>
>   * 不允许 key 为 null 也不允许 value 为 null
>   * 推荐使用 ``java.util.concurrent``包下的 ``ConcurrentHashMap``
>   * Hashtable 没有采用驼峰命名法
>   * 对外提供 ``elements()``和 ``contains`` 两个方法
>
>      * elements() 返回其所有 value 枚举
>      * contains() 返回是否包含这个 key
>   * 两种除了使用 Iterator 遍历，Hashtable 还使用了 Enumeration 遍历
>   * 默认初始值为 11，扩充则会增长为 2n+1
>   * 在 JDK 1.8 之前是没有[``fast-fail 机制``](https://github.com/DraperHXY/Notes/issues/20)
>   * Hash 计算使用了 JDK 提供的 hashcode



4、HashMap 和 ConcurrentHashMap 的区别

> * ConcurrentHashMap 
>   * 使用了桶数组进行分割分段，对每一个 segment 进行枷锁，粒度相较于 Hashtable 要细一些，并发性能更好，JDK 1.8 后使用了全新的实现方式 ``CAS``
>   * 不允许 null key 和 null value
>
> * HashMap 
>   * 非线程安全
>   * 允许 null key 和 null value



5、HashSet如何检查重复

> 首先通过 hashCode 来比较，如果相同则继续使用 equal 来比较



6、comparable 和 comparator的区别



7、如何对 Object 的 list 进行排序

> - Arrays.sort()
> - Collections.sort()



8、如何实现数组与List的相互转换

>* List<String> 转 String[]
>
>```java
>String[] strings = list.toArray(new String[list.size()]);
>```
>
>* String[] 转 List<String>
>
>```java
>List<String> stringList = Arrays.asList(strings);
>```



9、如何求ArrayList集合的交集 并集 差集 去重复并集

> 需要使用 List 提供的几个方法
>
> * addAll(Collection<? extends E> c) 
>
>   按照 Iterator 的顺序将参数集合追加到已有的 list 后面
>
> * retainAll(Collection<?> c)
>
>   保留参数中已有的元素返回一个交集
>
> * removeAll(Collection<?> c)
>
>   删除集合中指定的元素



10、== 与 equals 区别

> * == 
>
>   比较两个对象的地址
>
> * equals 
>
>   如果没有被覆盖，则等价于 ==



11、hashCode 与equals 的相关规定

> * 如果两个对象相等，则hashCode一定也是相同的
> * 两个对象相等，对两个对象分别调用 equals 方法都返回 true
> * 两个对象有相同的hashCode值，它们也不一定是相等的
> * **因此，equals方法被覆盖过，则hashCode方法也必须被覆盖**



12、HashSet 和 HashMap 的区别

> HashSet 底层是基于 HashMap，除了 ``clone`` ，``readObject`` ，``writeObject`` HashSet 自己实现以外，其他的直接调用 HashMap 的方法



### 多线程

1、简述线程，进程的基本概念。以及他们之间关系是什么？

> * 进程
>   * 资源分配的最小单位
>   * 一个进程有多个线程
>   * 不同进程之间数据很难共享
>   * 创建进程会消耗较多的系统资源
>   * 进程之间不会相互影响
>   * 进程使用内存地址时可以上锁
>   * 进程使用内存可以限定使用量
> * 线程
>   *  CPU 调度的最小单位，执行的基本单位
>   * 是进程的一部分
>   * 不同线程之间很容易共享数据
>   * 更为细小的时间段
>   * 能够快速的切换上下文



2、interrupt 的有效范围

* sleep()
* wait()
* 无法被互斥锁中断
* 无法中断 IO 操作

> 前两者低级阻塞，后两者高级阻塞



3、notify() 和 notifyAll() 区别

* notify 会随机唤醒一个正在等待该对象的线程，如果该线程发现不是事务与自己无关，则继续随机唤醒另外一个线程
* notify 会唤醒所有正在等待的线程



4、死锁的四个条件

* 互斥

某种资源只允许一个进程访问，资源一旦分给了某个进程，其他进程便不能访问，直到该进程访问结束

* 占有且等待

一个进程本身占有一定资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放资源

* 不可抢占

别人以拥有某个资源，不能因为自己也需要，就去抢占别人的资源

* 循环等待

存在一个进程链，每一个进程都占有下一个进程所需的一种资源。



###JVM

1、地球人都知道，Java有个东西叫垃圾收集器，它让创建的对象不需要像c/cpp那样delete、free掉，你能不能谈谈，GC是在什么时候，对什么东西，做了什么事情？

> 系统不可预测时间，调用 System.gc()
>
> 能说出新生代、老年代结构，能提出 minor gc/full gc
>
> 以及相应的触发条件、OOM 的触发条件，降低 GC 的调优策略
>
> 例如 eden 满了 minor gc，升到老年代的对象大于老年代剩余空间 full gc
>
> 或者小于时被 HandlePromotionFailure 参数强制 full gc
>
> gc 和 full gc 时间耗时超过了 GCTimeRatio 的限制引发 OOM
>
> 调优诸如通过 NewRatio 控制新生代老年代比例
>
> 通过 MaxTenuringThreshold 控制进入老年前生存次数等...
>
> 
>
> 对从 root 搜索不到，而且经过第一次标记，清理后，任然没有复活的对象
>
> 
>
> 新生代做的是复制清理、from survivor、to survivor 是干什么用的、老年代做的是标记清理，清理后碎片要不要整理、赋值清理和标记清理有什么优劣势
>
> 串行、并行(整理/不整理碎片)、CMS 等搜集器可作用的年代、特点、优劣势，并且能说明控制、调整收集器选择法
>
> 法
>
> * 新生代的垃圾回收
>
>   新对象的内存分配都是现在 Eden 区域，当 Eden  区域的空间不足于分配新对象时，就会触发年轻代上的垃圾回收（发生在 Eden 和 Survivor 内存区域上），我们称之为 "minor garbage collection"，同时，每个对象都有一个 "年龄"，这个年龄实际上是该对象经历过的 minor gc 的次数，所有存货的对象（任然可达对象）会被拷贝到其中一个 Survivor 区域，同时年龄增长为 1。并清除整个 Eden 内存区域中的非可达对象。
>
>   当第二次 minor gc 被触发时，JVM 会通过 Mark 算法找出所有在 Eden 内存区域和 Survivor1 内存区域存活的对象，并将它们拷贝到 Survivor2 区域（这也就是为什么需要两个大小一样的 Survivor 区域的原因），同时对象的年龄加 1，最后，清除所有在 Eden 内存区域和 Survivor1 的非可达对象。
>
>   当对象的年龄足够大（这个年龄可以通过 JVM 参数进行制定，这里假定是 2），当 minor gc 再次发生时，他会从 Survivor 内存你区域中升级到年老代
>
>   其实，即使对象的年龄不够大，但是 Survivor 内存区域中没有足够的空间来容纳 Eden 升级过来的对象时，也会有部分对象直接升级到 Tenured 内存区域汇中。
>
> * 年老代的垃圾回收
>
>   当 minor gc 发生时，又有对象从 Survivor 区域升级到 Tenured 区域已经没有空间容纳新的对象了，那么这个时候就会触发老年代上的垃圾回收，我们称之为 "major garbage collection"
>
>   而年老代上的选择的垃圾回收算法取决于 JVM 上采用的是什么垃圾回收器。垃圾回收器有两种 Parallel Scavenge(PS) 和 Concurrent Mark Sweep(CMS)。这两种垃圾回收器的不同更多的是体现在年老代的垃圾回收过程中，年轻代的垃圾回收在这两种垃圾回收器基本一致
>
>   就像其名字所表示的那样，Parallel Scavenge 垃圾回收器在执行垃圾回收时使用了多线程来记性垃圾回收，这样可以提高垃圾回收的效率。而 Concurrent Mark Sweep 垃圾回收器在进行垃圾回收时，应用程序可以同时进行。
>
> 原文 [Java 垃圾回收机制](https://www.jianshu.com/p/778dd3848196)





2、Java 和 C++ 在内存分配和管理上有什么区别？

> 对于从事 C 和 C++ 程序开发人员来说，在内存管理领域，既拥有每一个对象的所有权，又担负着每一个对象从生命开始到终结的维护责任
>
> 对于 Java 程序员来说，虚拟机的自动分配机制的帮助下，不再需要为每一个 new 操作去写配对的 delete/free 代码，而且不容易出现内存泄漏和内存溢出问题，看起来虚拟机管理内存一切都很美好。不过，也正是因为 Java 程序员将内存控制的权利交给 Java 虚拟机，一旦出现内存泄漏和内存溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查是一项异常艰难的工作
>
>  的
>
> 好的 Java 程序在编写时候肯定要考虑 GC 的问题，怎样定义 static 对象，怎样 new 对象效率高等等，简称面向 GC 的编程



3、Java 虚拟机规范将 JVM 虚拟机所管理的内存分为个部分

>* 程序计数器(Program Counter Register)
>
>  是一块比较小的内存空间，它的作用可以看做是当前线程所执行字节码的行号指示器。是线程私有，生命周期与线程相同
>
>* Java 虚拟机栈(Java Virtual Machine Stacks)
>
>  也是线程私有，生命周期与线程相同。Java 虚拟机栈描述的是 Java 方法(区别于 native 本地方法) 执行的内存模型：每个方法被执行的时候都会出现一个栈帧(Stack Frame) 用于存储局部变量表、操作栈、动作链接、方法出口等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
>
>* 本地方法栈(Native Method Stacks/VM Stack)
>
>  与虚拟机栈所发挥的作用非常相似，其区别不过是虚拟机栈为执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机所使用到的 Native 方法服务。
>
>* 方法区(Method Area)
>
>* 堆(Heap)



4、有哪些方法可以判断一个对象已经可以被回收，JVM怎么判断一个对象已经消亡可以被回收？

> * 引用计数法
>
>   给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加 1；当引用失效时，计数器值就减 1；任何时刻计数器都为 0 的对象就是不可能再被使用的。
>
>   Java 语言没有选用引用计数法来管理内存，因为引用计数法不能很好的解决循环引用的问题
>
>   ```java
>   class A {
>       public Object o;
>   }
>   class B {
>       public Object o;
>   }
>   void method(){
>       A a = new A();
>       B b = new B();
>       a.o = b;
>       b.o = a;
>       a = null;
>       b = null;
>   }
>   public static void main(String[] args) {
>       new Test1().method();
>   }
>   ```
>
> * 根搜索算法
>
>   在主流的商用语言中，都是使用根搜索算法来判定对象是否存货的。
>
>   GC Root Tracing 算法思路是通过一些列名为 ”GC Roots“ 的对象作为起始点，从这些节点向下搜索，搜索走过的路径被称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连，即从 GC Roots 到这个对象不可达，则证明此对象是不可用的。



5、哪些对象可以作为 GC Roots？

> * 虚拟机栈(栈帧中的本地变量表)中的引用的对象(作 GCRoots 又不会损失什么)
>
> * 方法去中类静态属性引用的对象
>
> * main thread 
>
>   一个 thread，本身就是一个大的实例，
>
> * 本地方法栈中（Native）的引用对象(JNI 引用)



6、在 Heap 中没有类的实例的时候，类信息还存在于 JVM 中吗？存在于什么地方？

> JVM 将堆分成了两大分区 Young 和 Old



7、JVM 垃圾回收算法

> * 因为引用计数法无法解决循环引用问题，JVM 并没有采用这种算法来判断对象是否存货
> * JVM 一般采用 GCRoots 发放，只要从任何一个 GCRoots 的对象科大，就是不被回收的对象



8、判断了对象的生死，怎么进行内存的清理呢？

>* 标记-清除算法
>
>先标记那些要被回收的对象，然后进行清理，简单可行，但是标记清除效率低，因为要一个一个标记和清除，造成大量不连续的内存碎片，空间碎片太多可能会导致当程序在以后的运行过程中需要分配较大对象的时候无法找到足够连续的内存而不得不触发另一次垃圾回收动作
>
>* 复制收集算法
>
>将可用内存按照容量分为大小相等的两块，每次只是使用其中一块。当这一块的内存用完了，就将可用内存汇总存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配也就不用考虑内存碎片等复杂情况，只要一动堆顶指针，按顺序分配内存即可。实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一般，未免太高了一点。
>
>> young 内存分为三块，Eden,Survivor1,Survivor2 以及 FROM TO 相对使用的用法。
>>
>> 前两者属于年轻代的垃圾回收，后者属于年老代的垃圾回收
>>
>> * 标记压缩算法
>> * 分代算法
>> * 分区算法
>



9、年老代的垃圾回收机制

> * Parallel Scavenge
>
> PS垃圾回收器在年老代上采用的垃圾回收算法可以看作是[标记-清除算法](https://www.jianshu.com/p/b0f5d21fe031)和[标记-压缩算法](https://www.jianshu.com/p/698eb5e1ccb9)的结合体。
>
> 首先，PS 垃圾回收器先是会在年老代上使用标记-清除算法来回收掉飞科达对象所占用的空间，但是我们知道，标记清除算法的一个缺陷就是会引起内存碎片问题。继而有可能会引发连续的 major gc。假设当前存在的内存碎片有 10M，但最大的内存碎片只能容纳 2M 的对象，这个时候如果有一个 3M 的对象从 Survivor 区域升级到 Tenured 区域，那 Tenured 区域也没有方法存放这个 3M 的对象。结果就是不断地触发 major gc,直到 Out of Memory。所以，PS 垃圾回收器在清除非可达对象后，还会进行一次 compact，来消除内存碎片。
>
> * Concurrent Mark Sweep
>
> CMS 垃圾收集器相比于 PS 垃圾收集器，它成功的减少了垃圾收集时暂停应用程序的时间，因为 CMS 在进行垃圾收集时，应用程序是可以并发运行的。
>
> 
>
> 从名字可以看出，CMS 垃圾收集器在年老代采用的垃圾回收算法是标记-清除算法。但是跟标准的标记-清除算法略有不同。主要分为四个阶段。
>
>   * Initial Mark 阶段
>
>  这个阶段是 Stop-The-World，他会暂停应用程序的运行，但是在这个阶段，他不会标记出在 Tenured 区域中所有的可达对象。他只会从根对象开始出发，标记到根对象的第一层孩子节点即停止。然后恢复应用程序的运行。所以，这个暂停应用程序的时间是很短的
>
>   * Concurrent Mark 阶段
>
>  在这个阶段中，CMS 垃圾回收器以 Initial Mark 阶段标记的节点为根对象，重新考试标记 Tenured 区域中的可达对象。当然，在这个阶段中是不需要暂停应用程序的。这也是它成为 "Concurrent Mark" 的原因。这同时也造成了一个问题，俺就是由于 CMS 垃圾回收器和应用程序同时运行，Concurrent Mark 阶段它并不保证 Tenured 区域的可达对象都被标记了，应用程序一直在分配新对象。
>
>   * Remark 阶段
>
>  由于 Concurrent Mark 阶段它并不保证在 Tenured 区域的可达对象都被标记，所以我们需要再次暂停应用程序，确保所有的可达对象都被标记。为了加快速度，这里也采用了多线程同时标记可达对象。
>
>   * Concurrent Sweep 阶段
>
>  最后，恢复应用程序的执行，同时 CMS 执行 sweep，来清除所有非可达对象所占用的内存空间。
>
> 所以，相比于 PS 垃圾收集器，CMS 垃圾收集器成功减少了应用程序暂停的时间。
>
>   * 除此之外 Java7 的发布了新的 Garbage First G1 垃圾回收器
>
> 原文 [Java 垃圾回收机制](https://www.jianshu.com/p/778dd3848196)



10、Java7 的 Garbage First 垃圾回收器

> Garbage First(G1) 垃圾收集器
>
> 但是很不幸的是，CMS 垃圾收集器虽然减少了暂停应用程序的运行时间，但是由于它没有 Compact 阶段，他还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时保留 CMS 垃圾收集器低暂停时间的优点，Java 7 发布了一个新的垃圾收集器 - G1 垃圾收集器。它会在未来逐步替换掉 CMS 垃圾收集器。
>
> 
>
> G1 垃圾收集器和 CMS 垃圾收集器有几点不同。首先，岁大的不同是内存的组织方式改变了。Eden, Survivor 和 Tenured 等内存区域不再是连续的了，而是变成了一个个大小一样的 region，每个 region 从 1M 到 32M 不等。
>
> 
>
> 一个 Region 有可能属于 Eden, Survivor 或者 Tenured 内存区域。G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，主要用于存储大对象，即大小超过了一个 region 大小的 50% 的对象。
>
> 
>
> 在 G1 垃圾收集器中，年轻代的垃圾回收过程和 PS 垃圾收集器和 CMS 垃圾收集器差不多，新对象的分配还是在 Eden region 中，当所有 Eden region 的大小超过某个值时，触发 minor gc，回收 Eden region 和 Survivor region 上的非可达对象，同时升级存活的咔哒对象到对应的 Survivor region 和 Tenured region 还是哪个。对象从 Survivor region 升级到 Tenured region 依然是取决于对象的年龄。
>
> 
>
> 对于年老代的垃圾收集，G1 垃圾收集器也分为 4 个阶段，基本跟 CMS 垃圾收集器一样，但略有不同
>
> 
>
> * Initial Mark 阶段
>
>   同 CMS 垃圾收集器的 Initial Mark 极端一样，G1 也需要暂停应用程序的执行，它会标记从根对象触发，在根对象的第一层孩子节点中标记所有可达的对象。但是 G1 的垃圾收集器的 Initial Mark 阶段是跟 minor gc 一同发生的。也就是说在 G1 中，不用像 CMS 那样，单独暂停应用程序的执行来运行 Initial Mark 阶段，而是在 G1 触发 minor gc 的时候一并将年老代上 Initial Mark 给做了。
>
> * Concurrent Mark 阶段
>
>   在这个阶段 G1 做的事情跟 CMS 一样。但 G1 同时还多做了一件事情，那就是，如果在 Concurrent Mark 阶段中，发现那些 Tenured region 汇总对象的存活率很小或者基本没有对象存活，那么 G1 就会在这个阶段将其回收掉，而不用等到后面的 clean up 阶段。这也是 Garbage First 名字的由来。同时在这个阶段，G1 会计算每个 region 的对象存活率，方便后面的 clean up 阶段使用
>
> * Remark 阶段
>
>   在这个阶段 G1 做的事情更 CMS 一样，但是采用的算法不同， G1 采用的叫做 SATB(snapshot-at-the-begining) 的算法能够在 Remark 阶段更快的标记可达对象。
>
> * Clean up/Copy 阶段
>
>   在 G1 中，没有 CMS 中对应的 Sweep 阶段。相反他有一个 Clean up/Copy 阶段，在这个阶段中，G1 会挑选出那些对象存活率低的 region 进行回收，这个阶段也是和 minor gc 一同发生的。











## 数据结构算法问题汇总

1、 BFS 和 DFS 的区别

> * BFS(Breadth First Search) 广度优先搜索
>
>   核心是一个队列
>
> * DFS(Depth First Search) 深度优先搜索
>
>   核心是递归



## 网络问题汇总

### 协议层次以及服务模型

1、什么是 TCP

> Transmission Control Protocol 传输控制协议
>
> 一种面向连接的，可靠的，基于字节流的传输层协议。TCP 提供的是全双工服务(full-duplex service),TCP 连接也总是点对点(point-to-point)



2、TCP 三次握手，四次挥手过程，参数

> TCP 建立和关闭连接使用了三次握手和四次挥手
> ![](/Users/draper/Documents/Developments/Java/Notes/img/2019-02-16-1.gif)
>
> * TCP 标志位，有 6 中标识
>   * SYN(synchronous 建立连接)
>   * ACK(acknowledgement 确认)
>   * PSH(push 传送)
>   * FIN(finish 结束)
>   * RST(reset 重置)
>   * URG(urgent 紧急)
>   * Sequence number(顺序号码) Acknowledge number(确认号码)



3、TCP/IP 模型

> * 物理层
>
>   为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性，确保原始的数据可以在各种物理媒体上传输，为设备之间的数据通信提供传输媒体及互联设备，为数据传输提供可靠的环境
>
> * 数据链路层
>
>   主要提供链路控制(同步，异步，二进制，HDLC)，差错控制(重发机制)，流量控制(窗口机制)
>
>   * MAC​
>
>     媒体接入控制，主要功能是调度，把逻辑信号映射到传输信道，负责根据逻辑信道的瞬时源速率为各个传输信道选择适当的传输格式
>
>   * FLC
>
>     无限链路控制，不仅能承载控制面的数据，而且也承载用户面的数据。
>
>   * BMC 
>
>     广播/组播控制，负责控制多播/组播业务
>
>   * FDCP
>
>     分组数据汇聚协议，负责对 IPO 包的包头进行压缩和解压缩，以提高空中接口无线资源的利用率
>
> * 网络层
>
>   提供阻塞控制，路由选择(静态路由，动态路由) 等
>
>   * IP 
>
>     IP 协议提供不可靠，无连接的传送服务.
>
>     功能主要是无连接数据包传输，数据包路由选择和差错控制。
>
>   * ARP
>
>     地址解析协议。基本功能室通过目标设备的 IP 地址，查询目标设备的 MAC 地址，以保证通信的顺利进行。
>
>   * RARP
>
>     反向地址转换协议。允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。
>
>   * IGMP
>
>     组播协议，包括组成员管理协议和组播路由协议。组成员管理协议用于管理组播组成员的加入和理考，组播路由协议负责在路由器之间交互信息来建立组播树。
>
>   * IGMP
>
>     Internet 控制报文协议。用于在 IP 主机、路由器之间传递控制消息。
>
>   * BGP
>
>     边界网关协议。处理像因特网大小的网络和不想管路由域间的多路连接
>
>   * RIP
>
>     路由信息协议。是一种分布式的基于距离矢量的路由选择协议
>
> * 传输层
>
>   提供分割与重组数据，按端口号寻址，连接管理差错控制和流量控制，纠错的功能。传输层要向会话层提供通信服务的可靠性，避免报文的出错、丢失、延迟时间紊乱、重复、乱序等差错。
>
>   * TCP
>
>     一种面向连接的、可靠地、基于字节流的传输层通讯协议
>
>   * UDP
>
>     用户数据包协议，一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。
>
>   * RTP
>
>     实时传输协议，为数据提供了具有实时特征的段对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。
>
>   * SCTP
>
>     一个面向连接的流控制传输协议，可以在两个端点之间提供稳定、有序的数据传递服务。可以看成 TCP 协议的改进，继承了 TCP 较为完善的拥塞控制，并改进了 TCP 的一些不足。
>
>     * SCTP 是多宿主连接，而 TCP 是单地址连接
>     * 一个 TCP 连接只能支持一个流，一个 SCTP 连接可以支持多个流
>     * SCTP 具有更好的安全性
>
> * 应用层
>
>   * HTTP
>
>     超文本传输协议，基于 TCP，使用于从 WWW 服务器传输超文本到本地浏览器的传输协议。可以使浏览器更加高效，使网络传输减少
>
>   * SMTP
>
>     简单邮件传输协议，是一组用于由原地址到目的地址传送邮件的规则，由它来控制信件的中转方式
>
>   * SNMP
>
>     简单网络管理协议，由一组网络管理的标准组成，包含一个应用层协议、数据库模型和一组资源对象。
>
>   * FTP
>
>     文件传输协议，用于 Internet 上的控制文件的双向传输。同时也是一个应用程序。
>
>   * Telnet
>
>     是 Internet 远程登录服务的标准协议和主要方式。为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。
>
>   * SSH
>
>     安全外壳协议，为建立在应用层和传输层基础上的安全协议。SSH 是目前比较可靠，专为远程登录会话和其他网络服务提供安全性的协议。
>
>   * NFS
>
>     网络文件系统，是 FreeBSD 支持的文件系统中的一种，允许网络中的计算机之间通过 TCP/IP 网络共享资源。



4、TCP 和 UDP 的区别？应用场景有何不同？

> * TCP
>   * 基于连接
>   * 对资源要求比较多
>   * TCP 重量级，元数据头大小为 16 字节
>   * 流模式
>   * TCP 保证数据准确，且保证数据顺序
>   * 适合金融等大多数领域
> * UDP
>   * 基于无连接
>   * 对系统资源要求小
>   * UDP 轻量级，元数据头大小为 8 字节
>   * 数据报模式
>   * UDP 可能丢包，并不保证数据顺序
>   * 适合游戏和娱乐场景
>   * UDP 应用场景
>     * 面向数据报方式
>     * 网络数据大多为短消息
>     * 拥有大量 Client
>     * 对数据安全性无特殊性要求
>     * 网络负担非常重，但对响应速度要求高



### Http 汇总

1、常见请求头

> * ``GET`` 默认 Http 请求方法
> * ``Host`` 指定请求资源的 Internet 主机和端口号
> * ``Accept`` 浏览器可接受的媒体类型
> * ``User-Agent`` 客户端所用的操作系统和浏览器名称和版本
> * ``Accept-Encoding`` 浏览器申明字节接收的编码方法，通常指定压缩方法，不仅仅是字符编码
> * ``Connection`` 是否需要持久连接



2、常见响应头

> * 状态行： 状态行由协议版本，数字形式的状态代码，及相应的状态描述组成，各元素之间以空格分隔，结尾时回车换行符例如:``HTTP/1.1 200 OK``
> * ``Expires`` 浏览器会在指定过期时间内使用本地缓存，指明应该在什么时候认为过期，并不再缓存它
> * ``Set-Cookie`` 用于把 Cookie 发送到客户端浏览器
> * ``Entity`` 实体头域，实体内容的属性，包括实体信息的类型，长度，压缩方法，最后一次修改时间，数据有效性等。
> * ``ETag`` 和 if-None-Match 配合使用
> * ``Last-Modified`` 用于只是资源的最后修改日期和时间。
> * ``If-None-Match`` 和 ETag 一起工作，工作原理是在 Http Response 中添加 ETag 信息。当用户再次请求该资源时，将在 Http Request 中加入 If-None-Match 信息（ETag 的值）。如果服务器验证资源的 ETag 没有改变(该资源没有更新)，将返回一个 304 状态告诉客户端使用本地缓存文件。否则将返回 200 状态和新的资源和 ETag，使用这样的机制将提高网站的性能
> * ``Server`` 指明 Http 服务器的软件信息
> * ``Pragma`` 防止页面被缓存，在 Http/1.1 版本中，它和 ``Cache-Control:no-cache`` 作用一模一样
> * ``Cache-Control:Public`` 可以被任何缓存所缓存
> * ``Cache-Control:Private`` 内容只缓存到私有缓存中
> * ``Cache-Control:no-cache`` 所有内容都不会被缓存
> * ``Content-Length`` 指定正文的长度，以字节方式存储十进制数字来表示





## 数据库问题汇总

1、数据库架构层面的优化

* 分库分表
* 读写分离
* 冷热分离，水平、垂直拆分库或者表

不明白原理强行模仿容易带来一些问题和挑战（造成夸库 join 和分布式事务）



2、gap 锁



3、乐观锁



4、



## Spring 问题汇总

1、什么是循环依赖，如何检测出循环依赖？

两个或两个以上的 bean 互相持有对方，最终造成闭环。




## 分布式问题汇总

1、如何保持分布式的事务一致性

使用两阶段提交的方法(2PC Two-phaseCommit)。核心思想是参与者将操作的成败通知协调者，再根据所有参与者的反馈信息来决定是否提交操作还是取消操作。

但有以下几点缺点

* 同步阻塞
* 单点故障
* 数据不一致性



或者使用三阶段提交

* 解决同步阻塞
* 解决单点故障




## Linux问题汇总

1、Linux 写过 Shell 脚本么

2、Linux 用过哪些命令

3、Linux CPU 100% 勘察问题





## HR 问题汇总

1、您在前一家公司的离职原因是什么？

2、讲一件你印象最深的一件事情；

* 解决 VUE 动态效果的实现，通过查阅 blog 确定方向，根据方向查阅解决方案



3、介绍一个你影响最深的项目；

4、介绍你最热爱最擅长的专业领域；

5、公司实习最大的收获是什么；

6、与上级意见不一致时，你将怎么办；

7、自己的优点和缺点是什么？并举例说明？

> 优点是容易对技术原理感兴趣，好奇是为什么实现。

> 缺点应该是跟高标准来比的

* 在算法等方面的知识比较薄弱

* 对于网络知识仅仅了解 TCP/IP，对应用层，传输层其他协议不太了解



8、你的学习方法是什么样的？实习过程中如何学习？实习项目中遇到的最大困难是什么以及如何解决的；

* 先了解技术产生的背景产生一个大致的概念
* 再去看看中文社区，或者博客看看一般的运用场景
* 去官方下载一个Quick Start 或者 Sample Example 快速上手
* 看下这方面好的书籍，继续深入学习，掌握这门技术。



9、说一件最能证明你能力的事情；

> 可以遵循 STAR 法则

有一次解决 Spring Cloud Eureka Server 读取 Spring Cloud Config 自动配置，但是只是报了一个 未找到 host 错误，我通过打断点的方式，找到原始的 http 请求，模拟操作，确定错误产生的原因是 Docker 间通信存在问题，后再在阿里云上将请求的 IP 地址换成了内网地址，成功解决 bug。



10、针对你你申请的这个职位，你认为你还欠缺什么；

> 这个其实跟第七个问题不一样，如何针对职位来说，看临机应变

* 缺少对一些算法上的问题的解决能力



11、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办；

12、项目中遇到最大的困难是什么？如何解决的；

13、你的职业规划以及个人目标；未来发展路线及求职定位；

14、如果你在这次面试中没有被录用，你怎么打算；

15、评价下自己，评价下自己的技术水平，个人代码量如何；

16、通过哪些渠道了解的招聘信息，其他同学都投了哪些公司；

17、业余都有哪些爱好；

18、你做过的哪件事最令自己感到骄傲；

> * 使用 ``github page`` + ``hexo`` 搭建博客
> * 使用原生的 ``Servlet`` + ``mysql`` + ``tomcat`` + ``bootstrap`` 搭建了一个音乐分享平台



19、假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办；

20、就你申请的这个职位，你认为你还欠缺什么；

21、当前的offer状况；如果BATH都给了offer该如何选；

22、你对一份工作更看重哪些方面？平台，技术，氛围，城市，money；

* 平台
* 技术



23、理想薪资范围；杭州岗和北京岗选哪个；

杭州，对于同样的薪资，杭州的对职位的要求明显不会比北京低，所以对人来说成长平台也就更高，现在地区之间没有太明显的划分



24、理想中的工作环境是什么；

25、谈谈你对跳槽的看法；

26、说说你对行业、技术发展趋势的看法；



27、实习过程中周围同事/同学有哪些值得学习的地方；

* 首先是同学优秀的前瞻性



28、家人对你的工作期望及自己的工作期望；

29、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办；

30、若上司在公开会议上误会你了，该如何解决；

31、是否可以实习，可以实习多久；

可以实习 8 个月，



32、在五年的时间内，你的职业规划；

* 首先是数据库，数据库调优有必要看。

* 框架是容易变得，不变的都是原理，所以会对 Java 基础继续巩固，对多线程，网络编程比较熟练
* 对设计模式，和代码重构能力要有相当的掌握
* 在编程中对  JVM 有调优能力
* 对于框架方面的学习，不能确定，主要是围绕着 Spring 全家桶来看，要对其原理要比较熟悉

* 同时对 Java 技术要有一定的前瞻性，保持终身学习的习惯



33、你看中公司的什么？或者公司的那些方面最吸引你。

* 公司大牛多
* 工作氛围好
* 福利待遇高
* 有潜力，符合我对未来的职业规划



34、做下自我介绍

> 应该从你适合这个岗位这个角度来回答，并非来相亲

我叫 XXX 来自 XXX，相比起其他技术更擅长做 Java 开发，对 Spring Boot + Spring Cloud 比较熟悉。对一些 Spring 底层原理，也有过一定的学习。例如Spring AOP 的实现， Spring Boot 中 ErrorMvcAutoConfiguration 的自动配置。对解决问题的能力也有一定的掌握。