# GC算法，垃圾收集器



## 一、对象存活判断

* 引用计数
* 可达性分析



**引用计数**：每个对象有一个引用计数属性，新增一个引用时计数+1，释放时引用计数-1，计数为0时可以回收。此方法简单，无法解决对象循环引用的问题。

**可达性分析**：从 GC Roots 向下开始搜索，搜索所有走过的路径成为引用链。当一个对象到 GC Roots 没有任何引用链时，则证明此对象是不可用的。



### 什么样的对象可以被当做 GC Roots?

* 虚拟机栈引用的对象
* 方法去中类静态属性实体引用的对象
* 方法去中常量引用的对象
* 本地方法栈中 JNI 引用的对象



## 二、垃圾收集算法

### 1. 标记-清除算法

标记-清除(Mark-Sweep) 算法，是较为基础的算法，如名字一样，算法分为"标记"和"清除“两个阶段：

首先标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以是最基础的算法，是因为后续的算法是以这种为基础并改正其缺点而得到的。



**缺点**：

1. 效率问题，标记和清除过程的效率都不高
2. 空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作



### 2. 复制算法

复制(Copying)收集算法，将内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块的内存用完了，那就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

**优点**：
每次都是对其中一块进行内存回收，内存分配时就不用考虑内存碎片的复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单运行高效

**缺点**
将内存缩小为原来的一半，持续复制长生存周期的对象导致效率降低



### 3. 标记-压缩算法

在复制收集算法中，需要对长生命周期的对象进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50% 的空间，就需要额外的空间进行分配担保，以应对使用的内存中对象 100% 都是存货的极端情况，所以在老年代一般不能直接选用这种算法

根据老年代的特点，有人提出了另外一种标记-整理(Mark-Compact)算法，标记过程仍然与"标记-清除"算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存货的对象都向一端移动，然后直接清理掉端边界以外的内存



### 4. 分代收集算法

GC 分代的基本假设：绝大部分对象的生命周期都是非常短暂，存活时间短

"分代收集"(Generational Collection) 算法，把 Java 堆分为新生代和老年代，这样可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现大批对象死去，只有少量存货，那就采用复制算法，只需要付出少量存货对象的复制成本，就可以完成收集。而老年代中对象存活率高、没有额外空间对它进行分配担保，就必须使用"标记-清理"或"标记-整理"算法来进行回收。



## 三、垃圾收集器

收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现

### 1. Serial 收集器

串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代和老年代在收集过程中会出现 STW(Stop The World)

新生代：复制算法
老年代：标记-压缩

参数控制: ``- XX:+ UseSerialGC``

### 2. ParNew 收集器 

ParNew 收集器其实就是 Serial 收集器的多线程版本。新生代并行，老年代串行。

新生代：并行，复制算法
老年代：串行，标记-压缩

参数控制：
``- XX: UseParNewGC`` ParNew 收集器
``- XX: ParallelGCThreads`` 限制线程数量

###3. Parallel 收集器

Parallel Scavenge 收集器类似 ParNew 收集器，Parallel 收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会更具当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大吞吐量，也可以通过参数控制 GC 的时间不大于多少毫秒或者比例

新生代：复制算法
老年代：标记-压缩

参数控制：``- XX:+UseParallelGC`` 使用 Parallel 收集器 + 老年代串行



### 4. Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和"标记-清理"算法。这个收集器是在 JDK1.6 中才开始提供

参数控制：``- XX:+UseParallelOldGC``使用 Paraellel 收集器+老年代并行



### 5. CMS 收集器

CMS(Concurrent Mark Sweep) 收集器是一种以获取最短时间为目标的收集器。目前很大一部分的 Java 应用都集中在互联网网站或 B/S 系统的服务端上，这类应用中是服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

CMS 的运作过程相较于前面几种更为复杂，整体分为四个步骤，包括：

* 初始标记(CMS initial Mark)
* 并发标记(CMS concurrent mark)
* 重新标记(CMS remark)
* 并发清除(CMS concurrent sweep)



**其中初始标记、重新标记这两个步骤仍然需要 STW**。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是 GC Roots Tracing 的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一点，但远比并发标记的时间短。

**由于整个过程中耗时最长的并发标记和并发清除中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS 收集器的内存回收过程与用户线程一起并发地执行。

**优点**：并发收集、低停顿
**缺点**：产生大量空间碎片、并发阶段会降低吞吐量

参数控制：

``-XX:+UseConcMarkSweepGC`` 使用 CMS 收集器
``-XX:+UseCMSCompactAtFullCollection`` Full GC 之后，进行一次碎片整理，整理过程是独占的，会引起停顿时间编程
``-XX:+CMSFullGCsBeforeCompaction`` 设置进行几次 Full GC 后，进行一次碎片整理
``-XX:ParallelCMSThreads`` 设定 CMS 的线程数量(一般情况约等于可用 CPU 数量)



### 6. G1 收集器

G1(Garbage First)收集器目前是技术发展最前沿成果之一，HotSpot 开发团队赋予它的使命是未来可以替换掉 JDK1.5 中发布的 CMS 收集器。与 CMS 收集器相比 G1 收集器有以下特点

1. 空间整合：G1 收集器采用标记整理算法，不会产生内存空间碎片。分配过大对象时不会因为无法找到连续空间而提前触发下一次 GC。
2. 可预测停顿：这是 G1 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为 N毫秒 的时间片段内，消耗在垃圾收集器上的时间不得超过 N毫秒，这几乎成为实时 java(RTSJ) 的垃圾收集器的特征了。



在使用 Java 堆中的内存布局和其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，他们都是一部分(可以不连续) Region 的集合。

G1 的新生代和 ParNew 类似，当新生代占用达到一定比例的时候，开始触发手机。和 CMS 类似，G1 收集器收集老年代对象会有短暂停顿

#### 收集步骤

1. 标记阶段，首先初始
2. Root Region Scanning
3. 并发标记
4. Remark
5. Copy/Clean up
6. 复制/清除过程后

[jvm系列(三):GC算法 垃圾收集器](<https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483952&idx=1&sn=ea12792a9b7c67baddfaf425d8272d33&chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&scene=21#wechat_redirect>)
[深入剖析JVM：*G1*收集器+回收流程+推荐用例](https://zhuanlan.zhihu.com/p/59861022)
[深入理解 Java *G1* *垃圾*收集器](https://zhuanlan.zhihu.com/p/43560613)






















