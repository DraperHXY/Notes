# 对象的创建

这里指的对象是普通 Java 对象，不是数组，也不是 Class 对象等。

当虚拟机遇到了一条 new 指令时，先去常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有先执行**类的加载过程**

在类加载检查通过后，接下来虚拟机将会为新生对象分配内存。对象所需的内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从堆中分割出来。



假设 Java 堆中内存是绝对规整的，所有用过的内存放在一边，所有空闲的内存放在一边儿，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是吧指针从空闲空间的那一边挪一段与对象大小相等的距离，这种方式称为指针碰撞。

如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那么没有办法简单的进行指针碰撞了，虚拟机就必须维护一个列表，上面记载了那谢谢内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种方式称为空闲列表。

**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。**

因此

* 指针碰撞
  * Serial
  * ParNew
* 空闲列表
  * CMS



除此之外，分配对象在 Java 虚拟机中还要考虑是否频繁，过于频繁的话，仅仅是指针碰撞也会出现线程不安全的的行为。

所以针对上述的情况也会采用两种方式，第一种是利用 CAS 配上失败重试的方式保证操作的原子性，**另一种是把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB），哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要进行同步锁定。**

虚拟机是否使用 TLAB，可以通过 -XX:+/-UseTLAB 参数决定



接下来虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代等信息。这些信息都存放在对象的对象头中。根据虚拟机运行状态的不同，比如是否启用偏向锁等、对象头会有不同的设置方式。



上面的工作都进行完成后，在虚拟机的角度来看，对象已经创建完成，但在 Java 程序的角度来看，对象还没有执行 <init> 方法。所以执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的医院进行初始化，这样一个真正可用的对象才算安全产生出来。



## 总结

1. 首先执行类加载的检查
2. 其次在堆中分配内存
3. 然后在对对象进行必要的设置
4. 最后执行 <init> 方法，成为一个真正的对象