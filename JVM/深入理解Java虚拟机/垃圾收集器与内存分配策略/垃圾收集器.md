# 垃圾收集器

* Serial
* ParNew
* Parallel Scavenge
* Serial Old
* Parallel Old
* CMS
* G1

## 一、Serial 收集器

新生代采用复制算法，暂停所有线程 (单线程复制)

老年代采取标记-整理算法，暂停所有用户线程 （单线程标记-整理）

这个垃圾收集器最重要的是他会在垃圾收集过程中，暂停所有线程，也就是 Stop The World ，这对应用来说很多时候是不能忍受的

---

## 二、ParNew 收集器

ParNew 收集器实质上是 Serial 收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括 Serial 收集器可用的所有控制桉树、手机算法、Stop The World、对象分配规则、回售策略都与 Serial 收集器完全一致。

注意 ParNew 收集器在单核心处理器的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程的交互开销，超线程技术实现的伪双核处理器环境中都不能百分百超越 Serial 收集器。

---

## 三、Parallel Scavenge 收集器

Parallel Scavenge 与其他的垃圾收集器关注点不同，比如说其他的垃圾收集器都在尽可能降低垃圾回收期间程序停顿的时间，但是 Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量。

吞吐量 = (运行用户代码时间) / (运行用户代码时间 + 运行垃圾收集时间)

主要适合在后台运算不需要太多交互的分析任务

---

## 四、Serial Old

主要有两个用途

1. 在 JDK 5 及之前的版本中与 Parallel Scavenge 收集器搭配使用
2. 作为 CMS 收集器发生失败时的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

---

## 五、Parallel Old 收集器

Parallel Old 是 Parallel 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。这个是在 JDK 6 时才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于相对尴尬的状态，原因是因为新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器之外别无选择，其他表现良好的老年代收集器，如 CMS 无法与它配合工作。

直到 Parallel Old 收集器出现后，“吞吐量有限”收集器才有了名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以有限考虑 Parallel Scavenge 加 Parallel Old 收集器组合。

---

## 六、CMS 收集器

CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。。目前很大一部分的 Java 应用几种在互联网网站或者基于浏览器的 B/S 系统的服务端上，这类因供应用哪个通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，已给用户带俩良好的交互体验。

CMS 从 Mark Sweep 就可以看出来是基于标记-清除算法实现的，运作过程相对于前面几种收集器来说更复杂一些，整个过程分为四个步骤。包括

1. 初始标记（CMS initial mark）（STW）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）（STW）
4. 并发清除（CMS concurrent sweep）

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体来说，CMS 收集器的内存回收过程与用户线程一起并发执行的。

但是 CMS 在并发阶段对处理器资源非常敏感。虽然不会导致用户线程停顿，但却会因为占用了一部分线程二导致应用程序变慢，降低总吞吐量。CMS 默认启动的回收线程是 (处理器核心数量 + 3) / 4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过 25% 的处理器运算资源，并且hi随着处理器核心数量的增加而下降。但是处理器核心数量不足四个时，CMS 对用户程序的影响就可能变得很大。如果应用处理器负载就很高，还要分出一半的运算能力去执行收集线程，就可能导致用户程序的执行速度忽然大幅度降低。为了缓解这种情况，虚拟机提供了一种称为“增量式并发收集器”的 CMS 收集器变种，所做的事情和以前单核处理器年代 PC 机操作系统靠抢占式多任务来模拟多喝并行多任务的思想一样，就是在并发标记、清理的时候让手机线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源时间，这样整个垃圾收集的过程就会更长，但对用户程序的影响就会显得较少一些，直观感受是速度变慢的时间更多了，但速度下降幅度就没有那么明显。实践证明增量式的 CMS 收集器效果很一般，从 JDK 7 时， i - CMS 模式已经被声明 “deprecated”，到 JDK 9 发布后 i - CMS 模式被完全废弃。

然而，由于 CMS 收集器无法处理浮动垃圾，有可能出现 “Con-current Model Failure” 失败进而导致另一次完全 “Stop The World” 的 Full GC 的产生。在 CMS 的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随新的垃圾对象不断产生，但这一部分垃圾对象是出现标记过程结束以后，CMS 无法在档次收集中处理掉他们，只好留待下一次垃圾收集时再清理掉。由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此 CMS 收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时程序运作使用。CMS 在 JDK 5 的默认设置下，当老年代使用了 68% 的空间后就会被激活，这是一个偏保守的设置，如何实际应用中老年代增长并不是太快，可以适当调高参数 -XX:CMSInitiatingOccu-pancyFraction 的值来提高 CMS 触发的百分比，降低内存回收的频率，获取更好地性能。到 JDK 6 时，CMS 收集器的启动阈值就已经默认提升到 92%。但这优惠更容易面临另一种奉献：要是 CMS 运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure） 这时候虚拟机将不得不启动后备源：冻结用户线程的执行，临时启动 Serial Old 收集器来重新进行老年代的垃圾手机，但这样停顿时间就很长了。所以参数 -XX:CMSInitiatingOccupancyFraction 设置的太高就会很容易导致大量并发失败的产生，性能反而降低。

还有最后一个缺点，CMS 是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。为了解决这个问题，CMS 收集器提供了一个 -XX:+UseCMS-CompactAtFullCollection 开关参数（默认是开启的，此参数 JDK9 开始废弃），用于在 CMS 收集器不得不进行 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction（此参数 JDK9 废弃）这个参数的作用是要求 CMS 收集器在执行若干次（数量由参数值决定）不整理空间的 FullGC 之后，下一次进入 FullGC 前会进行碎片整理（默认值为0，表示每次进入 FullGC 时都进行碎片整理）

---

## 七、Garbage First

Garbage First 作为一款里程碑式的垃圾收集器，开创了收集器面向局部收集的的设计思路和基于 Region 的内存布局形式。

在 G1 收集器出现之前的所有其他收集器，包括 CMS 在内，垃圾收集的目标范围要么是整个新生代，要么是整个老年代，再要么就是整个 Java 堆。而 G1 跳出了这个樊笼，可以面向堆内存任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存汇总存放的垃圾数量最好多，回收收益最大，这就是 G1 收集器的 MixedGC 模式。

G1 开创额基于Region 的堆内存布局是它能够实现这个目标的关键。虽然 G1 也是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为对哦个大小相等的独立区域，每个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。收集器能够扮演不同角色的 Region 采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集旧对象都能获取很好的收集效果。

Region 中海油一类特殊的 Humongous 区域，专门用来存储大对象。G1 认为只要大小超过了一个 Region 容量一半的对爱那个即可判定为大对象。每个 Region 的大小可以通过参数 ``-XX:G1HeapRegionSize`` 设定，取值范围为 1MB~32MB，且对应 2 的 N 次幂。而对于哪些超过了整个 Region 容量的超大对象，将会被存在 N 个连续的 Humongous Region 之中， G1 的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待。



目前在小内存应用上 CMS 的表现大概率任然会优于 G1，而在大内存应用上 G1 则大多数能发挥其优势，这个优劣势的 Java 堆容量平衡点通常在 6GB 至 8 GB 之间。

---























