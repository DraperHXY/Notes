# 判断对象生死

## 一、判断对象生死的算法

### 1. 引用计数法

给对象添加一个引用计数器，每当一个地方引用这个对象，计数器的值+1，当引用失效时，计数器值就-1。当对象的引用数目为 0 时，代表不会再被使用，那么就可以回收内存了。

实际上，有很多著名的案例，表明这还算是一种不错的算法，比如 MicroSoft 的 COM(Component Object Model) 技术、 使用 ActionScript3 的 FlashPlayer、Python 语言在游戏脚本领域被广泛应用的 Squirrel 中都使用了引用计数算法记性内存管理。

但是，主流 Java 虚拟机并没有选择这种算法，因为**无法解决循环依赖的问题（对象之间相互循环引用）**

### 2. 可达性分析算法

主流的商用程序语言(Java、C#，甚至 Lisp) 的主流实现中，都是通过可达性分析算法来判断对象是否存活。

通过一系列 “GC ROOTS” 的对象作为起始点，从这些节点向下搜索，所走过的路径被称为引用链，当一个对象到 GC ROOT 没有任何引用链相连时，则证明此对象是不可用的。



### 3. 可以作为 GC ROOTS 的对象

* 虚拟机栈中（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法去中常量引用的对象
* 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

---

## 二、关于对象的引用类型

在 JDK 1.2 之前，对引用的描述还是很传统：如果 reference 类型的数据总存储的数值代表的是另外一块内存的起始地址，九成这块内存代表的是一个引用。这种描述过于狭隘，无法描述那些更加复杂的情况，所以在 JDK 1.2 之后，Java 对引用的概念进行了扩充。引用的类型分为了 4 类

### 1. 强引用

即使内存不足，JVM 宁愿抛出异常也不愿意回收强引用的对象。

### 2. 软引用

当内存充足时，软引用不会被进行回收。只有当内存不足时（OOM 前），进行垃圾回收才会将软引用对象进行回收，回收后没有足够的内存，同样会 OOM。在 JDK 1.2 后，提供 ``SoftReference`` 类来实现软引用

### 3. 弱引用

只要 GC，无论内存是否足够，都会进行垃圾回收。在 JDK 1.2 后，提供 ``WeakReference`` 类来实现弱引用

### 4. 虚引用

这是最弱的一种引用关系，完全不会对其生存时间构成影响，唯一的目的是，对象被回收前时会收到一个系统通知。在 JDK 1.2 后，提供 ``PhantomReference`` 来实现虚引用。

---

## 三、决定对象生存还是死亡

在上述的可达性算法中不可达的对象，也并非必须要被回收。要真正宣告一个对象死亡，至少要被标记两次的过程。

### 1. 第一次被标记

如果一个对象没有与 GC Roots 相连接，并进行一次筛选。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。

### 2. 第二次被标记

如果这个对象有必要执行 finalize() 方法，那么这个对象会被放置在一个 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的 Finalizer 线程执行 finalize() 方法，会触发，但并不绝对死亡，还有一次逃脱的机会。

稍后 GC 将堆 F-Queue 中的对象进行第二次小规模的标记，如果对象要拯救自己，则需要把自己的引用赋值给类变量，或者是某个对象的成员变量，那么在第二次标记则会被移除即将回收的集合，如果没有的话，基本上就真的被回收了。

---

## 四、回收方法区

Java 虚拟机规范并没有要求必须在方法区进行垃圾回收，并且在方法区进行垃圾回收性价比比较低，在堆中一般可以回收 70% - 90% 的内存，在方法去远低于此

主要回收两部分内容：废弃常量和无用的类

判断常量是否该废弃比较容易，与堆中的对象比较相似。但是判断废弃的类就比较严格，需要满足以下三个条件：

1. 该类所有实例都已经被回收
2. 加载该类的 ClassLoader 已经被回收
3. 该类所对应的 Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的任何方法

