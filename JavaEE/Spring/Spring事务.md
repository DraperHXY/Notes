# Spring 事务



谈起 Spring 事务，实际的实现还是依赖数据库事务，而数据库事务则是依赖数据库锁

**所以，Spring 事务依赖的是数据库锁**

所以数据库的理论基本，在 Spring 事务中依然可以实践

**注意，Spring 事务不能保证数据一致性和业务逻辑正确性**

## 一、Spring 事务的传播属性

| 常量名称                  | 常量解释                                                     |
| ------------------------- | ------------------------------------------------------------ |
| PROPAGATION_REQUIRED      | 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务传播 |
| PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，把当前事务挂起。新建的事务       |
| PROPAGATION_SUPPORTS      | 执行当前事务，如果当前没有事务，就以非事务方式执行           |
| PROPAGATION_MANDATORY     | 支持当前事务，如果当前没有事务，就抛出异常                   |
| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起     |
| PROPAGATION_NERVER        | 以非事务方式执行，如果当前存在事务，则抛出异常               |
| PROPAGATION_NESTED        | 如果一个活的的事务存在，则运行在一个嵌套事务中。如果没有活动事务，则按 REQUIRED 属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对 DatasOURCEtRANSACTIONmANAGER 事务管理器起效 |



## 二、数据库隔离级别

| 级别名称        | 级别值 | 导致的问题                     |
| --------------- | ------ | ------------------------------ |
| READ_UNCOMMIT   | 0      | 可能导致脏读，幻读，不可重复读 |
| READ_COMMITED   | 1      | 可能导致幻读，不可重复读       |
| REPEATABLE_READ | 2      | 可能导致幻读                   |
| SERIALIZABLE    | 3      | 串行化，事务一个一个执行。     |



## 三、Spring 事务隔离级别

| 常量                       | 解释                                                         |
| -------------------------- | ------------------------------------------------------------ |
| ISOLATION_DEFAULT          | PlatformTransactionManager 默认隔离级别，使用数据库默认的事务隔离级别。剩下的事务与数据库事务隔离级别相对应 |
| ISOLATION_UNCOMMITTED_READ |                                                              |
| ISOLATION_COMMITTED_READ   |                                                              |
| ISOLATION_REPEATABLE_READ  |                                                              |
| ISOLATION_SERIALIZABLE     |                                                              |





## 四、各种读的区别

### 1. 脏读

脏读是数据库最低的隔离级别，一个事务可以获取其他未 commit 的事务数据

### 2. 不可重复读

有一个超长时间的事务 A，进行多次读取操作。在此期间另外一个事务 B，修改了数据，而事务 A 前后读到的数据不一致，出现了不可复现，这就是不可重复读

### 3. 幻读

在执行表级操作的时候，有概率前后数据或增或少，这就是幻读

### 4. 串行化

并发下，才会有数据同步的问题出现，如果把所有的事务串行化，一个一个处理就不会影响到其他的数据

























