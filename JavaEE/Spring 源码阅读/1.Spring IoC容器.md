``Type Hierarchy`` - 键入层次结构



## IoC - Inversion of Control

控制反转，将对象的控制权利从我们人为的手中交给容器去解决，其中最重要的一点就是解决程序，类之间的耦合，换句话说就是避免长的调用链或无意义的封装。

> 在一个类中需要使用一个对象，而这个对象通常是作为参数被传进来的，我们需要修改接口，修改实现类…很麻烦，我要继续修改回去也是一样。并且往往在很多封装情况下，找不到我们真正需要的对象，我们可以根据 beanname 







容器进行对象生命周期管理，可以很合理注入到我们需要的地方。



## DI - Dependency Injection

依赖注入，从 IoC 中我们可以很容易的对对象的生命周期进行管理，但是在我们需要对象的时候，就需要容器来为我们提供。



所以说，IoC 具备理论意义，而 DI 则是实际实现。把复杂对象注入到我们需要的地方



DI 技术在 Java 的实现是 动态代理 以及 字节码代理



## 走一遍 IoC 容器的创建

* Spring Version: 5.1.4.RELEASE





* IoC 创建方式：见下代码 6 - 8 行

```java
@Test
public void testGetBean() {
    ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
    Resource resource = resolver.getResource("classpath:ApplicationContext.xml");
  
    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
    reader.loadBeanDefinitions(resource);
  
    System.out.println("init BeanFactory");
    User user = factory.getBean("user", User.class);
    System.out.println("user bean is ready for use");
}
```





看一下我们创建 Bean 的 Factory 在 Spring IoC 中的地位

![image-20190404133321890](../../img/image-20190404133321890.png)



简单介绍下各个类

* ``AliasRegistry`` - 接口，一些 register 、remove、is 方法声明
* ``SimpleAliasRegistry`` - 提供 Alias register 的实现
* **``DefaultSingletonBeanRegistry``** - ==内部包含多个集合对象，用作容器==，实现一些 shared bean 注册中心
* ``FactoryBeanRegistrySupport``  - 用作对单例注册中心的支持
* **``AbstractBeanFactory``** - 是 ``BeanFactory`` 的实现，提供了 full capabilities，例如 Slngleton 的缓存等
* ``AbstractAutowireCapableBeanFactory``
* ``DefaultListableBeanFactory`` 列出可用的 Bean，顶级接口只能获取一个，这个容器可以获取多个 Bean



---

```java
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(resource);
```



#### XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);

使用 DefaultListableBeanFactory 来获取 Xml 文件中 Bean 的 Reader，然后通过 reader 去加载我们的 xml 文件，来实例化 bean

试着 debug 可以看见一个方法

```java
protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {
	this.registry = registry;
	if (this.registry instanceof ResourceLoader) {
		this.resourceLoader = (ResourceLoader) this.registry;
	} else {
		this.resourceLoader = new PathMatchingResourcePatternResolver();
	}
  if (this.registry instanceof EnvironmentCapable) {
		this.environment = ((EnvironmentCapable) this.registry).getEnvironment();
	} else {
		this.environment = new StandardEnvironment();
	}
}
```



注意第 6 行， ``PathMatchingResourcePatternResolver`` 有两个作用

* 提供一个资源路径匹配，``AntMatcher``

* 提供一个 DefaultResourceLoader 主要获取了一个 ClassUtil 下的 DefaultClassLoader

注意第 11 行， 

* ``StandardEnvironment`` ，负责加载操作系统的 Properties 和 Environment

  > ```org.springframework.core.env.AbstractEnvironment#getSystemProperties`` 这个方法将会获取一些列系统资源，如下图，很容易通过名字判断
  >
  > ![开 IDEA DEBUG 信息](../../img/image-20190404140040166.png)
  >
  > 

---



#### reader.loadBeanDefinitions(resource);

算一下我们现在有了什么，**我们现在有一个创建 Bean 的 Factory，还有一个资源 Reader，**其实我比较在意到底在什么时候创建 Bean

```java
public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDef
	Assert.notNull(encodedResource, "EncodedResource must not be null");
	if (logger.isTraceEnabled()) {
		logger.trace("Loading XML bean definitions from " + encodedResource);
	}
	Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded
	if (currentResources == null) {
		currentResources = new HashSet<>(4);
		this.resourcesCurrentlyBeingLoaded.set(currentResources);
	}
	if (!currentResources.add(encodedResource)) {
		throw new BeanDefinitionStoreException(
				"Detected cyclic loading of " + encodedResource + " - check yo
	}
	try {
		InputStream inputStream = encodedResource.getResource().getInputStream
		try {
			InputSource inputSource = new InputSource(inputStream);
			if (encodedResource.getEncoding() != null) {
				inputSource.setEncoding(encodedResource.getEncoding());
			}
			return doLoadBeanDefinitions(inputSource, encodedResource.getResou
		}
		finally {
			inputStream.close();
		}
	}
	catch (IOException ex) {
		throw new BeanDefinitionStoreException(
				"IOException parsing XML document from " + encodedResource.get
	}
	finally {
		currentResources.remove(encodedResource);
		if (currentResources.isEmpty()) {
			this.resourcesCurrentlyBeingLoaded.remove();
		}
	}
}
```

这个方法直接定位到第 22 行，进入 doLoadBeanDefinitions，详细方法见下

![image-20190404225712488](../../img/image-20190404225712488.png)

可以看到**根据一个字节流和我们的文件路径开始向 BeanFactory 注册(registerBeanDefinitions)我们的 Bean ** 

![image-20190404230715984](../../img/image-20190404230715984.png)

确实在我们的 xml 文件中读取



接下来的 debug 比较乱，emmm，核心思路就是解析 xml 文件

















