## MySQL数据类型

系统查询语句来设计 schema，这往往需要权衡各种因素。例如，反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式，但这些表的维护成本可能会很高。

MySQL 独有的特性和实现细节可能对性能的影响也很大。

## 一、选择优化的数据类型

### 1. 更小的通常更好

一般情况下，应该尽量使用可以**正确**存储数据的最小数据类型。更小的数据类型通常更快，因为占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期更少。

但是要确保没有低谷需要存储值的范围，因为在 schema 中的多个地方增加数据类型的范围是一个非常耗时和痛苦的操作。如果无法确定那个数据类型最好的，就选择你认为不会超过范围的最小类型。

### 2. 简单就好

简单数据类型的操作通常需要更少的 CPU 周期。例如，整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。

> 这里有两个例子
>
> 1. 应该使用 MySQL 内建的类型，而不是字符串来存储日期和时间
> 2. 应该用整型存储 IP 地址

### 3. 尽量避免 NULL

很多表都包含可为 NULL 的列，即使应用程序并不需要保存 NULL 也是如此，这是因为可为  NULL 是列的默认属性。通常情况下最好指定列为 NOT NULL，除非真的需要存储 NULL 值。

如果查询中包含可谓 NULL 的列，对 MySQL 来说更难优化，因为可谓 NULL 的列使得 索引、索引统计也需要特殊处理。当 NULL 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）编程可变大小的索引。

通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小，所以（调优时）没有必要首先在现有 schema 中查找并修改掉这种情况，除非确定会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计成可谓 NULL 的列。

当然也有例外，InnoDB 使用单的的为存储 NULL 值，所以对于稀疏数据有很好的空间效率。但这一点不适用于 MyISAM



## 二、选择具体的类型

很多 MySQL 的数据类型可以存储相同类型的数据，知识存储的长度和范围不一样，允许的精度不同，或者需要的物理空间（磁盘和内存空间）不同。相同大类型的不同子类型数据有时也有一些特殊的行为和属性。

> 例如 DATETIME 和 TIMESAMP 列都可以存储相同类型的数据：时间和日期，精确到秒，然而 TIMESTAMP 只使用 DATETIME 一半的存储空间，并且会根据实物变化，具有特殊的自动更新能力。另一方面， TIMESTAMP 允许的时间范围要小得多，有时候他的特殊能力会成为障碍。



### 1. 整数类型

### 2. 实数类型

### 3. 字符串类型

> 使用 VARCHAR(5) 和 VARCHAR(200) 存储 “hello” 的空间开销是一样的。那么使用更短的列有什么优势吗？
>
> 事实证明有很大的优势。更长的列会消耗更多的内存你，因为 MySQL 通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用磁盘零时表进行排序是也同样糟糕。
>
> 所以最好的策略是只分配真正需要的空间

### 4. 日期和时间类型

### 5. 位数据类型

### 6. 选择标识符

### 7. 特殊类型数据









