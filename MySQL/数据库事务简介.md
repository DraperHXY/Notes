经典的有脏读、丢失修改、不可重复读、幻读，区别再不赘述

* 不可重复读强调于修改
* 幻读强调于新增和删除



## 一、事务隔离级别

### 1. READ UNCOMMITTED

事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。这个级别会导致很多问题，从性能上来说， READ UNCOMMITTED 不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非有非常必要的理由，在实际应用中一般很少会使用。

### 2. READ COMMITTED

大多数数据库的默认级别都是 READ COMMITTED （但 MySQL 不是）。一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始知道提交之前，所做的任何修改对其他事务都是不可见的。这个几遍有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。

### 3. REPEATABLE READ

REPEATABLE READ 解决了脏读的问题。该级别保证了在同一个事务中读取同样记录的结果是一致的，但是理论上，可重复度隔离级别还是无法解决另外一个幻读的问题。所谓幻读，指的是当谋改革事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，档之前的事务再次读取该范围的记录时，会产生幻行。InnoDB 和 XtraDB 解决了幻读的问题。



### 4.SERIALIZABLE



| 隔离级别         | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| :--------------- | :--: | :--------: | :--: | :----: |
| READ UNCOMMITTED |  Y   |     Y      |  Y   |   N    |
| READ COMMITTED   |  N   |     Y      |  Y   |   N    |
| REPEATABLE READ  |  N   |     N      |  Y   |   N    |
| SERIALIZABLE     |  N   |     N      |  N   |   Y    |



---

不同的数据库对标准的实现略有不同。

```sql
mysql> SELECT @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
1 row in set, 1 warning (0.00 sec)
```

InnoDB 的默认隔离级别是 **REPEATABLE-READ** 可重读

但是 MySQL 可重读实现了 **Next-Key Lock** 可以避免幻读，所以说即使是在 **REPEATABLE-READ** 级别下，也可以到达完全的 ACID。



## 二、死锁

数据库中的两个事务都在等待对方释放资源，从而陷入了等待的恶性循环。

为了解决这个问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如 InnoDB 存储引擎，越能检测到死锁的循环依赖，并返回一个错误。或者是当查询的时间达到等待超时的设定后放弃锁请求，这种方式通常来说不太好。

InnoDB 目前的处理方式是，将持有最少行级排他锁的事务进行回滚

锁的行为和顺序是和存储引擎相关的，以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有些是有双重原因：有些是因为真正的数据冲突，而有些则是由于存储引擎的实现方式引起的。

```sql
mysql> SHOW VARIABLES LIKE 'AUTOCOMMIT';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)
```



















