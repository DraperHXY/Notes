# MVCC

MVCC 应该属于锁策略的一种，在前面提过的排他锁描述时，当对表进行新增、修改、删除时会进行表锁定。但是基于提升并发效率的提升，会实现多版本并发控制（MVCC）。不仅是 MySQL、包括 Oracle 还是 PostgreSQL 都实现了 MVCC，但各自的实现机制不尽相同。

MVCC 是一个行级锁的变种，但在很多情况下避免了加锁的操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞操作，写操作也只锁定必要的行。

MVCC 的实现，通过保存数据在某个时间点的快照来实现，也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

## InnoDB MVCC

InnoDB 的 MVCC 是通过每行记录后面保存两个隐藏列来实现，一个是保存了行的创建时间，一个保存行的过期时间（或删除时间）



那么看下在 **REPEATABLE READ** 隔离级别下的操作

InnoDB 会根据一下两个条件检查每行记录

a. InnoDB 只查找版本遭遇当前事务版本的数据行（也就是，行的系统版本号小于或登录事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在，要么是事务自身插入或者修改过的。

b. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前为被删除。

只有符合上述两个条件的记录，才能返回作为查询结果。

* INSERT InnoDB 为新插入的每一行保存当前系统版本号作为行版本号
* DELETE InnoDB 为每一行保存当前系统版本号作为行版本号
* UDPATE InnoDB 为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识



MVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIABLE 则会对所有读取的行都加锁。